in the /admin route of the frontend it fails to load the data in the backend i don't know why because it is not even logging anything so please help me fix this issue ensure that the properties are being load as need be units, room types, recent reports and recent tenants make sure it works well with the backend here is some of the code let me know if you need anything else to further assist me in this task
ensure there is no mock data just actual real data

import React from 'react'
import { createContext, useState, useContext, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { tenantsAPI, propertiesAPI, paymentsAPI, communicationAPI } from '../services/api';

export const AppContext = createContext();

const ContextProvider = (props) => {
  // API data states
  const [tenants, setTenants] = useState([]);
  const [properties, setProperties] = useState([]);
  const [propertyUnits, setPropertyUnits] = useState([]);
  const [transactions, setTransactions] = useState([]);
  const [reports, setReports] = useState([]);

  // Loading and error states
  const [tenantsLoading, setTenantsLoading] = useState(false);
  const [propertiesLoading, setPropertiesLoading] = useState(false);
  const [unitsLoading, setUnitsLoading] = useState(false);
  const [transactionsLoading, setTransactionsLoading] = useState(false);
  const [reportsLoading, setReportsLoading] = useState(false);

  const [tenantsError, setTenantsError] = useState(null);
  const [propertiesError, setPropertiesError] = useState(null);
  const [unitsError, setUnitsError] = useState(null);
  const [transactionsError, setTransactionsError] = useState(null);
  const [reportsError, setReportsError] = useState(null);

  // Fetch tenants from API
  const fetchTenants = async () => {
    try {
      setTenantsLoading(true);
      setTenantsError(null);
      const response = await tenantsAPI.getTenants();
      setTenants(response.data);
    } catch (error) {
      console.error('Error fetching tenants:', error);
      setTenantsError('Failed to load tenants');
    } finally {
      setTenantsLoading(false);
    }
  };

  // Fetch properties from API
  const fetchProperties = async () => {
    try {
      setPropertiesLoading(true);
      setPropertiesError(null);
      const response = await propertiesAPI.getProperties();
      setProperties(response.data);
    } catch (error) {
      console.error('Error fetching properties:', error);
      setPropertiesError('Failed to load properties');
    } finally {
      setPropertiesLoading(false);
    }
  };

  // Fetch property units from API
  const fetchPropertyUnits = async () => {
    try {
      setUnitsLoading(true);
      setUnitsError(null);
      const response = await propertiesAPI.getUnits();
      // Transform API data to match expected format
      const transformedUnits = response.data.map(unit => ({
        id: unit.id,
        unitNumber: unit.unit_number,
        type: unit.unit_type?.name || 'N/A',
        rent: unit.rent || 0,
        size: unit.size || 'N/A',
        status: unit.is_available ? 'available' : 'occupied',
        isAvailable: unit.is_available,
        tenant: unit.tenant?.name || null,
        propertyId: unit.property_obj?.id?.toString() || unit.property?.toString()
      }));
      setPropertyUnits(transformedUnits);
    } catch (error) {
      console.error('Error fetching property units:', error);
      setUnitsError('Failed to load property units');
    } finally {
      setUnitsLoading(false);
    }
  };

  // Fetch transactions from API
  const fetchTransactions = async () => {
    try {
      setTransactionsLoading(true);
      setTransactionsError(null);
      const response = await paymentsAPI.getPaymentHistory();
      // Transform API data to match expected format
      const transformedTransactions = response.data.map(txn => ({
        id: txn.id,
        tenantId: txn.tenant?.id || txn.tenant_id,
        date: txn.created_at || txn.date,
        description: txn.description,
        amount: txn.amount,
        type: txn.transaction_type || txn.type,
        status: txn.status,
        reference: txn.reference_number || txn.reference,
        paymentMethod: txn.payment_method,
        propertyId: txn.property?.id?.toString() || txn.property_id?.toString()
      }));
      setTransactions(transformedTransactions);
    } catch (error) {
      console.error('Error fetching transactions:', error);
      setTransactionsError('Failed to load transactions');
    } finally {
      setTransactionsLoading(false);
    }
  };

  // Fetch reports from API
  const fetchReports = async () => {
    try {
      setReportsLoading(true);
      setReportsError(null);
      const response = await communicationAPI.getReports();
      setReports(response.data);
    } catch (error) {
      console.error('Error fetching reports:', error);
      setReportsError('Failed to load reports');
    } finally {
      setReportsLoading(false);
    }
  };

  // Fetch all data on component mount
  useEffect(() => {
    fetchTenants();
    fetchProperties();
    fetchPropertyUnits();
    fetchTransactions();
    fetchReports();
  }, []);

  // Selected property (so admin pages know which property is active)
  const [selectedPropertyId, setSelectedPropertyId] = useState(null);

  // Set default selected property when properties are loaded
  useEffect(() => {
    if (properties.length > 0 && !selectedPropertyId) {
      setSelectedPropertyId(properties[0].id.toString());
    }
  }, [properties, selectedPropertyId]);

  // Helper functions
  const getUnitsByProperty = (propertyId) => {
    return (propertyUnits || []).filter(u => u.propertyId === propertyId);
  };

  const getPropertyUnitStats = (propertyId) => {
    const unitsForProperty = getUnitsByProperty(propertyId);
    const total = unitsForProperty.length;
    const available = unitsForProperty.filter(u => u.isAvailable).length;
    const occupied = unitsForProperty.filter(u => u.status === 'occupied').length;
    const revenue = unitsForProperty
      .filter(u => u.status === 'occupied')
      .reduce((s, u) => s + (Number(u.rent) || 0), 0);
    return { total, available, occupied, revenue, units: unitsForProperty };
  };

  const getTransactionsByTenant = (tenantId) => {
    return transactions.filter(t => t.tenantId == tenantId); // loose equality to tolerate string/number ids
  };

  // Property management functions (for local state updates)
  const addUnit = (newUnit) => {
    setPropertyUnits(prev => [...prev, newUnit]);
  };

  const updateUnitAvailability = (unitId, isAvailable) => {
    setPropertyUnits(prev =>
      prev.map(unit => {
        if (unit.id === unitId) {
          return {
            ...unit,
            isAvailable: isAvailable,
            status: isAvailable ? 'available' : 'occupied'
          };
        }
        return unit;
      })
    );
  };

  // Placeholder functions for missing property management
  const addProperty = (landlordId, propertyData) => {
    // Placeholder: Add property to local state or call API
    console.log('Adding property:', propertyData);
    // For now, just log; implement API call if needed
  };

  const updateProperty = (propertyId, updatedData) => {
    // Placeholder
    console.log('Updating property:', propertyId, updatedData);
  };

  const addRoomType = (propertyId, roomTypeData) => {
    // Placeholder
    console.log('Adding room type:', roomTypeData);
  };

  const deleteRoomType = (roomTypeId) => {
    // Placeholder
    console.log('Deleting room type:', roomTypeId);
  };

  // Transaction management placeholders
  const addTransaction = (transactionData) => {
    // Placeholder
    console.log('Adding transaction:', transactionData);
  };

  const applyPayment = (paymentData) => {
    // Placeholder
    console.log('Applying payment:', paymentData);
  };

  return (
    <AppContext.Provider value={{
      // API data
      tenants,
      properties,
      propertyUnits,
      transactions,
      reports,

      // Loading states
      tenantsLoading,
      propertiesLoading,
      unitsLoading,
      transactionsLoading,
      reportsLoading,

      // Error states
      tenantsError,
      propertiesError,
      unitsError,
      transactionsError,
      reportsError,

      // Property selection
      selectedPropertyId,
      setSelectedPropertyId,

      // Property management
      addProperty,
      updateProperty,
      addRoomType,
      deleteRoomType,
      addUnit,
      updateUnitAvailability,

      // Helper functions
      getUnitsByProperty,
      getPropertyUnitStats,
      getTransactionsByTenant,

      // Transaction management
      addTransaction,
      applyPayment,

      // Backward compatibility - map tenants to mockTenants for existing components
      mockTenants: tenants,
      landlords: [], // Simplified - could be expanded if needed
      setLandlords: () => {}, // Placeholder
    }}>
      {props.children}
    </AppContext.Provider>
  )
}

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppContext Provider');
  }
  return context;
};


export default ContextProvider;

// ============== ADD PROPERTY FORM COMPONENT ==============
export const AddPropertyForm = () => {
  const navigate = useNavigate();
  const { addProperty } = useContext(AppContext);
  const [formData, setFormData] = useState({
    name: '',
    numberOfUnits: '',
    city: '',
    waterRate: '',
    electricityRate: '',
    mpesaType: 'till',
    mpesaStoreNumber: '',
    mpesaTillNumber: '',
    rentPenaltyType: '',
    taxRate: 7.5,
    recurringBills: [{ type: '', amount: '' }],
    managementFee: '',
    streetName: '',
    companyName: '',
    notes: '',
    paymentInstructions: '',
    ownerPhone: '+254'
  });

  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};
    // Required fields
    if (!formData.name.trim()) newErrors.name = 'Property name is required';
    if (!formData.numberOfUnits || isNaN(formData.numberOfUnits) || Number(formData.numberOfUnits) <= 0) newErrors.numberOfUnits = 'Number of units must be a positive number';
    if (!formData.city.trim()) newErrors.city = 'City is required';
    if (!formData.streetName.trim()) newErrors.streetName = 'Property address is required';
    if (!formData.ownerPhone.match(/^\+254\d{9}$/)) newErrors.ownerPhone = 'Phone must be in +254XXXXXXXXX format';

    // Water/Electricity rates
    if (formData.waterRate === '' || isNaN(formData.waterRate) || Number(formData.waterRate) < 0) newErrors.waterRate = 'Water rate must be a positive number';
    if (formData.electricityRate === '' || isNaN(formData.electricityRate) || Number(formData.electricityRate) < 0) newErrors.electricityRate = 'Electricity rate must be a positive number';

    // MPESA validation
    if (formData.mpesaType === 'paybill') {
      if (!formData.mpesaStoreNumber.trim()) newErrors.mpesaStoreNumber = 'Store number is required for Paybill';
      if (!formData.mpesaTillNumber.match(/^\d+$/)) newErrors.mpesaTillNumber = 'Paybill number must be numeric';
    } else if (formData.mpesaType === 'till') {
      if (!formData.mpesaTillNumber.match(/^\d+$/)) newErrors.mpesaTillNumber = 'Till number must be numeric';
    }

    return newErrors;
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    setErrors(prev => ({ ...prev, [name]: undefined }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validate();
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    // Add property to context
    addProperty('LL001', formData);

    // Prepare for backend (commented out)
    /*
    try {
      const response = await fetch('/api/properties', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      if (!response.ok) throw new Error('Failed to add property');
      // Optionally handle response
    } catch (err) {
      alert('Error sending data to backend');
      return;
    }
    */

    alert('Property added successfully!');
    navigate('/admin/organisation');
  };

  const handleClear = () => {
    setFormData({
      name: '',
      numberOfUnits: '',
      city: '',
      waterRate: '',
      electricityRate: '',
      mpesaType: 'till',
      mpesaStoreNumber: '',
      mpesaTillNumber: '',
      rentPenaltyType: '',
      taxRate: 7.5,
      recurringBills: [{ type: '', amount: '' }],
      managementFee: '',
      streetName: '',
      companyName: '',
      notes: '',
      paymentInstructions: '',
      ownerPhone: '+254'
    });
  };

  return (
    <div className="min-h-screen bg-gray-50 py-8 px-4">
      <div className="max-w-3xl mx-auto">
        <button
          onClick={() => navigate('/admin/organisation')}
          className="mb-6 flex items-center text-blue-600 hover:text-blue-800 font-medium"
        >
          <span className="mr-2">←</span> Back
        </button>
        <div className="bg-white rounded-lg shadow-md p-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-8">Property Form</h1>
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Property Name */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Property Name <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                name="name"
                value={formData.name}
                onChange={handleInputChange}
                placeholder="Property Name ..."
                className={`col-span-2 px-4 py-2 border ${errors.name ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                required
              />
              {errors.name && <span className="text-red-500 col-span-3 text-sm">{errors.name}</span>}
            </div>
            {/* Number of Units */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Number of units <span className="text-red-500">*</span>
              </label>
              <input
                type="number"
                name="numberOfUnits"
                value={formData.numberOfUnits}
                onChange={handleInputChange}
                min="1"
                className={`col-span-2 px-4 py-2 border ${errors.numberOfUnits ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                required
              />
              {errors.numberOfUnits && <span className="text-red-500 col-span-3 text-sm">{errors.numberOfUnits}</span>}
            </div>
            {/* City */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                City <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                name="city"
                value={formData.city}
                onChange={handleInputChange}
                placeholder="City or nearest town ..."
                className={`col-span-2 px-4 py-2 border ${errors.city ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                required
              />
              {errors.city && <span className="text-red-500 col-span-3 text-sm">{errors.city}</span>}
            </div>
            {/* MPESA */}
            <div className="grid grid-cols-3 gap-4 items-start">
              <label className="text-right font-medium text-gray-700 pt-2">
                MPESA <span className="text-red-500">*</span>
              </label>
              <div className="col-span-2 space-y-3">
                <div className="flex gap-4">
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name="mpesaType"
                      value="paybill"
                      checked={formData.mpesaType === 'paybill'}
                      onChange={handleInputChange}
                      required
                      className="mr-2"
                    />
                    Paybill
                  </label>
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name="mpesaType"
                      value="till"
                      checked={formData.mpesaType === 'till'}
                      onChange={handleInputChange}
                      className="mr-2"
                    />
                    Till Number
                  </label>
                </div>
                {formData.mpesaType === 'paybill' && (
                  <div>
                    <label className="text-sm text-gray-600 flex items-center mb-1">
                      Store Number
                      <span className="ml-1 text-gray-400 cursor-help" title="Store Number Info">ⓘ</span>
                    </label>
                    <input
                      type="text"
                      name="mpesaStoreNumber"
                      value={formData.mpesaStoreNumber}
                      onChange={handleInputChange}
                      className={`w-full px-4 py-2 border ${errors.mpesaStoreNumber ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                      required={formData.mpesaType === 'paybill'}
                    />
                    {errors.mpesaStoreNumber && <span className="text-red-500 text-sm">{errors.mpesaStoreNumber}</span>}
                  </div>
                )}
                <div>
                  <label className="text-sm text-gray-600 mb-1 block">
                    {formData.mpesaType === 'paybill' ? 'Paybill Number' : 'Till Number'}
                  </label>
                  <input
                    type="text"
                    name="mpesaTillNumber"
                    value={formData.mpesaTillNumber}
                    onChange={handleInputChange}
                    className={`w-full px-4 py-2 border ${errors.mpesaTillNumber ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                    required
                  />
                  {errors.mpesaTillNumber && <span className="text-red-500 text-sm">{errors.mpesaTillNumber}</span>}
                </div>
              </div>
            </div>
            {/* Street Name */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Property Address <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                name="streetName"
                value={formData.streetName}
                onChange={handleInputChange}
                placeholder="Address / Closest street Name ..."
                required
                className={`col-span-2 px-4 py-2 border ${errors.streetName ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
              />
              {errors.streetName && <span className="text-red-500 col-span-3 text-sm">{errors.streetName}</span>}
            </div>
            {/* Owner Phone Number */}
            <div className="grid grid-cols-3 gap-4 items-start">
              <label className="text-right font-medium text-gray-700 pt-2 flex items-center">
                Owner Phone Number <span className="text-red-500">*</span>
                <span className="ml-1 text-gray-400 cursor-help" title="Phone Info">ⓘ</span>
              </label>
              <div className="col-span-2">
                <input
                  type="tel"
                  name="ownerPhone"
                  value={formData.ownerPhone}
                  onChange={handleInputChange}
                  required
                  placeholder="+254XXXXXXXXX"
                  className={`w-full px-4 py-2 border ${errors.ownerPhone ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
                />
                <p className="text-sm text-gray-500 mt-1">
                  The phone number should be in international format: +254XXXXXXXXX.
                </p>
                {errors.ownerPhone && <span className="text-red-500 text-sm">{errors.ownerPhone}</span>}
              </div>
            </div>
            {/* Water Rate */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Water Rate (Ksh per unit)
              </label>
              <input
                type="number"
                name="waterRate"
                value={formData.waterRate}
                onChange={handleInputChange}
                min="0"
                step="0.01"
                placeholder="e.g., 50"
                className={`col-span-2 px-4 py-2 border ${errors.waterRate ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
              />
              {errors.waterRate && <span className="text-red-500 col-span-3 text-sm">{errors.waterRate}</span>}
            </div>
            {/* Electricity Rate */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Electricity Rate (Ksh per unit)
              </label>
              <input
                type="number"
                name="electricityRate"
                value={formData.electricityRate}
                onChange={handleInputChange}
                min="0"
                step="0.01"
                placeholder="e.g., 25"
                className={`col-span-2 px-4 py-2 border ${errors.electricityRate ? 'border-red-500' : 'border-gray-300'} rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent`}
              />
              {errors.electricityRate && <span className="text-red-500 col-span-3 text-sm">{errors.electricityRate}</span>}
            </div>
            {/* Tax Rate */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Tax Rate (%)
              </label>
              <input
                type="number"
                name="taxRate"
                value={formData.taxRate}
                onChange={handleInputChange}
                min="0"
                step="0.01"
                placeholder="e.g., 7.5"
                className="col-span-2 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            {/* Management Fee */}
            <div className="grid grid-cols-3 gap-4 items-start">
              <label className="text-right font-medium text-gray-700 pt-2">
                Management Fee
              </label>
              <div className="col-span-2 space-y-3">
                <div className="flex gap-4">
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name="managementFee"
                      value="percentage"
                      checked={formData.managementFee === 'percentage'}
                      onChange={handleInputChange}
                      className="mr-2"
                    />
                    Percentage
                  </label>
                  <label className="flex items-center">
                    <input
                      type="radio"
                      name="managementFee"
                      value="fixed"
                      checked={formData.managementFee === 'fixed'}
                      onChange={handleInputChange}
                      className="mr-2"
                    />
                    Fixed Amount
                  </label>
                </div>
                {formData.managementFee && (
                  <input
                    type="number"
                    name="managementFeeValue"
                    value={formData.managementFeeValue}
                    onChange={handleInputChange}
                    min="0"
                    step="0.01"
                    placeholder={formData.managementFee === 'percentage' ? 'e.g., 10' : 'e.g., 5000'}
                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                )}
              </div>
            </div>
            {/* Company Name */}
            <div className="grid grid-cols-3 gap-4 items-center">
              <label className="text-right font-medium text-gray-700">
                Company Name
              </label>
              <input
                type="text"
                name="companyName"
                value={formData.companyName}
                onChange={handleInputChange}
                placeholder="Company Name ..."
                className="col-span-2 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            {/* Notes */}
            <div className="grid grid-cols-3 gap-4 items-start">
              <label className="text-right font-medium text-gray-700 pt-2">
                Notes
              </label>
              <textarea
                name="notes"
                value={formData.notes}
                onChange={handleInputChange}
                placeholder="Additional notes about the property ..."
                rows="3"
                className="col-span-2 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            {/* Payment Instructions */}
            <div className="grid grid-cols-3 gap-4 items-start">
              <label className="text-right font-medium text-gray-700 pt-2">
                Payment Instructions
              </label>
              <textarea
                name="paymentInstructions"
                value={formData.paymentInstructions}
                onChange={handleInputChange}
                placeholder="Instructions for tenants on how to pay rent ..."
                rows="3"
                className="col-span-2 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            {/* Submit Buttons */}
            <div className="pt-6 space-y-3">
              <button
                type="submit"
                className="w-full bg-blue-900 text-white py-3 rounded-lg hover:bg-blue-800 font-semibold text-lg flex items-center justify-center"
              >
                <span className="mr-2">+</span> Add Property
              </button>
              <button
                type="button"
                onClick={handleClear}
                className="w-full bg-white border-2 border-gray-300 text-gray-700 py-3 rounded-lg hover:bg-gray-50 font-semibold"
              >
                Clear
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};
import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
import { communicationAPI } from '../services/api';

const NotificationContext = createContext();

export const useNotifications = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotifications must be used within a NotificationProvider');
  }
  return context;
};

export const NotificationProvider = ({ children }) => {
  
  const [notifications, setNotifications] = useState({
    reports: {
      count: 0,
      hasNew: false,
      lastChecked: null
    }
  });
  
  // Check for new reports using API
  const checkForNewReports = useCallback(async () => {
    try {
      const response = await communicationAPI.getOpenReports();
      const openReports = response.data;
      const newReportsCount = openReports.length;

      setNotifications(prev => {
        // Only update if the count actually changed
        if (prev.reports.count === newReportsCount) {
          return prev;
        }

        return {
          ...prev,
          reports: {
            count: newReportsCount,
            hasNew: newReportsCount > prev.reports.count,
            lastChecked: new Date()
          }
        };
      });
    } catch (error) {
      console.error('Error checking for new reports:', error);
    }
  }, []);

  // Mark reports as viewed
  const markReportsAsViewed = useCallback(() => {
    setNotifications(prev => ({
      ...prev,
      reports: {
        ...prev.reports,
        hasNew: false,
        lastChecked: new Date()
      }
    }));
  }, []);

  // Check for new reports periodically
  useEffect(() => {
    checkForNewReports();
    const interval = setInterval(checkForNewReports, 30000); // Check every 30 seconds
    return () => clearInterval(interval);
  }, [checkForNewReports]);

  return (
    <NotificationContext.Provider value={{
      notifications,
      checkForNewReports,
      markReportsAsViewed
    }}>
      {children}
    </NotificationContext.Provider>
  );
};

export default NotificationProvider;
from .models import CustomUser, Property, Unit, UnitType, TenantProfile
from rest_framework import serializers

from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.core.mail import send_mail

# Overide the token to use email instead of username for JWT authentication
# accounts/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser
import uuid

# accounts/serializers.py
class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    username_field = "email"

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        requested_user_type = attrs.get("user_type")  # User type from frontend

        if not email or not password:
            raise serializers.ValidationError("Must include 'email' and 'password'")

        # Authenticate user
        user = authenticate(self.context['request'], email=email, password=password)
        
        if not user:
            raise serializers.ValidationError("Invalid email or password")
        
        if not user.is_active:
            raise serializers.ValidationError("User account is disabled")
        
        # If user_type is provided, validate it matches
        if requested_user_type and user.user_type != requested_user_type:
            raise serializers.ValidationError(
                f"Invalid account type. This account is registered as a {user.user_type}, not a {requested_user_type}."
            )
        
        # Use the actual user type from the database
        actual_user_type = user.user_type
        
        # Add user_type to validated data
        attrs['user_type'] = actual_user_type
        
        data = super().validate(attrs)
        data['user_type'] = actual_user_type
        data['user_id'] = user.id
        data['email'] = user.email
        data['full_name'] = user.full_name
        
        return data



class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'email',
            'full_name',
            'national_id',
            'id_document',
            'landlord_code',
            'date_joined',
            'user_type',
            'is_active',
            'is_staff',
            'is_superuser',
            'mpesa_till_number',
            'phone_number',
            'emergency_contact',
            'reminder_mode',
            'reminder_value',
            'password'
        ]
        read_only_fields = ['id', 'date_joined', 'is_active', 'is_staff', 'is_superuser', 'landlord_code']
        extra_kwargs = {
            'password': {'write_only': True}
        }

    def create(self, validated_data):
        # Always use the manager to ensure password is hashed
        # adapt to new signature: email, full_name, user_type, password
        email = validated_data.pop('email')
        full_name = validated_data.pop('full_name')
        user_type = validated_data.pop('user_type')
        password = validated_data.pop('password', None)
        user = CustomUser.objects.create_user(email=email, full_name=full_name, user_type=user_type, password=password, **validated_data)
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == 'password':
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

    def validate_phone_number(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid phone number in international format, e.g. +2547XXXXXXXX")
        return value

    def validate_emergency_contact(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid emergency contact phone number in international format")
        return value

        
class PropertySerializer(serializers.ModelSerializer):
    class Meta:
        model = Property
        fields = ['id', 'landlord', 'name', 'city', 'state', 'unit_count']
        read_only_fields = ['id', 'landlord']
    def create(self, validated_data):
        property = Property.objects.create(**validated_data)
        return property
    
class UnitTypeSerializer(serializers.ModelSerializer):
    # Remove landlord from fields - we'll handle it in the view
    class Meta:
        model = UnitType
        fields = ['id', 'name', 'rent', 'deposit', 'description', 'created_at', 'number_of_units']
        read_only_fields = ['id', 'created_at']

    def validate_rent(self, value):
        if value <= 0:
            raise serializers.ValidationError("Rent must be a positive number")
        return value

    def validate_deposit(self, value):
        if value < 0:
            raise serializers.ValidationError("Deposit cannot be negative")
        return value

    # Remove any create method - let the view handle setting the landlord


# In your serializers.py - Update UnitSerializer
class UnitSerializer(serializers.ModelSerializer):
    property_obj = serializers.PrimaryKeyRelatedField(queryset=Property.objects.all())
    unit_type = serializers.PrimaryKeyRelatedField(queryset=UnitType.objects.all(), required=False, allow_null=True)
    
    class Meta:
        model = Unit
        fields = [
            'id', 'property_obj', 'unit_code', 'unit_number', 'unit_type',
            'bedrooms', 'bathrooms', 'floor', 'rent', 'deposit', 'is_available',
            'tenant'
        ]
        read_only_fields = ['id', 'unit_code', 'tenant']

    def validate(self, data):
        # Ensure the property belongs to the current user
        if 'property_obj' in data and data['property_obj'].landlord != self.context['request'].user:
            raise serializers.ValidationError("You do not own this property")
        
        # Ensure unit type belongs to the current user if provided
        if 'unit_type' in data and data['unit_type'] and data['unit_type'].landlord != self.context['request'].user:
            raise serializers.ValidationError("You do not own this unit type")
            
        return data

    def create(self, validated_data):
        # Generate unit code if not provided
        if 'unit_code' not in validated_data or not validated_data['unit_code']:
            property_obj = validated_data['property_obj']
            unit_number = validated_data['unit_number']
            validated_data['unit_code'] = f"U-{property_obj.id}-{unit_number}-{uuid.uuid4().hex[:8]}"
        
        return super().create(validated_data)

class UnitNumberSerializer(serializers.ModelSerializer):
    class Meta:
        model = Unit
        fields = ['unit_number']

# TODO: Ensure landlords create properties and units upon sign up this will be done in the frontend
# TODO: Ensure Tenants pay the deposit to book a unit and choose their property upon sign up
# TODO: Ensure Tenants and Landlords can reset their passwords and get email notifications for important actions 


# For reset password functionality
class PasswordResetSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        if not CustomUser.objects.filter(email=value).exists():
            raise serializers.ValidationError("User with this email does not exist.")
        return value

    def save(self):
        from django.conf import settings
        email = self.validated_data['email']
        user = CustomUser.objects.get(email=email)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        # Use the configurable frontend URL from settings
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Password Reset Request",
            message=f"Click the link to reset your password: {reset_link}",
            from_email=None,
            recipient_list=[email],
        )


class PasswordResetConfirmSerializer(serializers.Serializer):
    uid = serializers.CharField()
    token = serializers.CharField()
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        from django.contrib.auth.tokens import default_token_generator
        from django.utils.http import urlsafe_base64_decode
        from django.contrib.auth.password_validation import validate_password
        try:
            uid = urlsafe_base64_decode(attrs['uid']).decode()
            user = CustomUser.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, CustomUser.DoesNotExist):
            raise serializers.ValidationError("Invalid UID")

        if not default_token_generator.check_token(user, attrs['token']):
            raise serializers.ValidationError("Invalid or expired token")

        validate_password(attrs['new_password'], user)
        attrs['user'] = user
        return attrs

    def save(self):
        user = self.validated_data['user']
        new_password = self.validated_data['new_password']
        user.set_password(new_password)
        user.save()
        return user


class ReminderPreferencesSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['reminder_mode', 'reminder_value']


class AvailableUnitsSerializer(serializers.ModelSerializer):
    landlord_id = serializers.CharField(source='property_obj.landlord.landlord_code', read_only=True)
    property_id = serializers.IntegerField(source='property_obj.id', read_only=True)
    property_name = serializers.CharField(source='property_obj.name', read_only=True)
    unit_number = serializers.CharField(read_only=True)

    class Meta:
        model = Unit
        fields = ['landlord_id', 'property_id', 'property_name', 'unit_number']

class TenantWithUnitSerializer(serializers.ModelSerializer):
    """ENHANCED: Special serializer for tenant management with unit data"""
    current_unit = serializers.SerializerMethodField()
    unit_data = serializers.SerializerMethodField()
    rent_status = serializers.SerializerMethodField()
    
    class Meta:
        model = CustomUser
        fields = [
            'id', 'email', 'full_name', 'phone_number', 'emergency_contact',
            'national_id', 'date_joined', 'current_unit', 'unit_data', 'rent_status'
        ]
    
    def get_current_unit(self, obj):
        """Get the unit currently assigned to this tenant"""
        try:
            unit = Unit.objects.get(tenant=obj)
            return {
                'id': unit.id,
                'unit_number': unit.unit_number,
                'property_name': unit.property_obj.name,
                'rent': unit.rent,
                'rent_paid': unit.rent_paid,
                'rent_remaining': unit.rent_remaining,
                'assigned_date': unit.assigned_date
            }
        except Unit.DoesNotExist:
            return None
    
    def get_unit_data(self, obj):
        """Alternative method to get unit data"""
        unit = Unit.objects.filter(tenant=obj).first()
        if unit:
            return UnitSerializer(unit).data
        return None
    
    def get_rent_status(self, obj):
        """Calculate rent status for the tenant"""
        try:
            unit = Unit.objects.get(tenant=obj)
            if unit.rent_remaining == 0:
                return 'paid'
            elif unit.rent_remaining == unit.rent:
                return 'due'
            elif unit.rent_remaining > 0:
                return 'overdue'
            else:
                return 'unknown'
        except Unit.DoesNotExist:
            return 'no_unit'
class LandlordDashboardSerializer(serializers.Serializer):
    """Serializer for landlord dashboard data"""
    total_properties = serializers.IntegerField()
    total_units = serializers.IntegerField()
    occupied_units = serializers.IntegerField()
    vacant_units = serializers.IntegerField()
    total_tenants = serializers.IntegerField()
    pending_applications = serializers.IntegerField()
    total_rent_collected = serializers.DecimalField(max_digits=10, decimal_places=2)
    total_rent_due = serializers.DecimalField(max_digits=10, decimal_places=2)
    
    recent_tenants = TenantWithUnitSerializer(many=True)
    recent_payments = serializers.ListField()

class CustomUserSerializer(serializers.ModelSerializer):
    user_type_display = serializers.CharField(source='get_user_type_display', read_only=True)
    
    class Meta:
        model = CustomUser
        fields = [
            'id', 'email', 'full_name', 'user_type', 'user_type_display',
            'national_id', 'landlord_code', 'date_joined', 'phone_number',
            'emergency_contact', 'mpesa_till_number', 'reminder_mode', 'reminder_value'
        ]
        read_only_fields = ['date_joined', 'landlord_code']

class TenantProfileSerializer(serializers.ModelSerializer):
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)
    tenant_email = serializers.CharField(source='tenant.email', read_only=True)
    unit_number = serializers.CharField(source='current_unit.unit_number', read_only=True)
    property_name = serializers.CharField(source='current_unit.property_obj.name', read_only=True)
    
    class Meta:
        model = TenantProfile
        fields = [
            'id', 'tenant', 'tenant_name', 'tenant_email', 'current_unit',
            'unit_number', 'property_name', 'move_in_date', 'lease_end_date',
            'emergency_contact_name', 'emergency_contact_phone'
        ]
from django.urls import path
from rest_framework_simplejwt.views import TokenRefreshView
from .views import (
    MyTokenObtainPairView,
    UserDetailView,
    UserListView,
    UserCreateView,
    PasswordResetView,
    PasswordResetConfirmView,
    UpdateUserView,
    MeView,
    LandlordDashboardStatsView,
    UnitTypeListCreateView,
    UnitTypeDetailView,
    CreatePropertyView,
    LandlordPropertiesView,
    CreateUnitView,
    PropertyUnitsView,
    AssignTenantView,
    UpdatePropertyView,
    UpdateUnitView,
    TenantUpdateUnitView,
    AdjustRentView,
    SubscriptionStatusView,
    UpdateTillNumberView,
    UpdateReminderPreferencesView,
    LandlordAvailableUnitsView,
    WelcomeView,
    LandlordsListView,
    PendingApplicationsView,
    EvictedTenantsView,
    TenantRegistrationStepView,
    LandlordRegistrationStepView,
    CompleteTenantRegistrationView,
    CompleteLandlordRegistrationView,
    AdminLandlordSubscriptionStatusView,
    UnitListView,  # ADD THIS
    ValidateLandlordView,  # ADD THIS
    LandlordProfileView,  # ADD THIS
    RemoveTenantFromUnitView,  # ADD THIS if it exists
)

urlpatterns = [
    # Authentication
    path('token/', MyTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    
    # User management
    path('users/', UserListView.as_view(), name='user-list'),
    path('users/<int:user_id>/', UserDetailView.as_view(), name='user-detail'),
    path('users/<int:user_id>/update/', UpdateUserView.as_view(), name='user-update'),
    path('register/', UserCreateView.as_view(), name='user-create'),
    path('me/', MeView.as_view(), name='me'),
    
    # Password reset
    path('password/reset/', PasswordResetView.as_view(), name='password-reset'),
    path('password/reset/confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Property management
    path('properties/', LandlordPropertiesView.as_view(), name='property-list'),
    path('properties/create/', CreatePropertyView.as_view(), name='property-create'),
    path('properties/<int:property_id>/', UpdatePropertyView.as_view(), name='property-detail'),
    path('properties/<int:property_id>/units/', PropertyUnitsView.as_view(), name='property-units'),
    
    # Unit management
    path('units/', UnitListView.as_view(), name='unit-list'),  # ✅ ADD THIS
    path('units/create/', CreateUnitView.as_view(), name='unit-create'),
    path('units/<int:unit_id>/', UpdateUnitView.as_view(), name='unit-detail'),
    path('units/<int:unit_id>/assign/<int:tenant_id>/', AssignTenantView.as_view(), name='assign-tenant'),
    path('units/<int:unit_id>/remove-tenant/', RemoveTenantFromUnitView.as_view(), name='remove-tenant'),  # ADD THIS
    path('units/tenant/update/', TenantUpdateUnitView.as_view(), name='tenant-update-unit'),
    
    # Unit types
    path('unit-types/', UnitTypeListCreateView.as_view(), name='unit-type-list'),
    path('unit-types/<int:pk>/', UnitTypeDetailView.as_view(), name='unit-type-detail'),
    
    # Dashboard & Stats
    path('dashboard/stats/', LandlordDashboardStatsView.as_view(), name='dashboard-stats'),
    path('rent/adjust/', AdjustRentView.as_view(), name='adjust-rent'),
    
    # Subscription
    path('subscription/status/', SubscriptionStatusView.as_view(), name='subscription-status'),
    path('till-number/update/', UpdateTillNumberView.as_view(), name='update-till-number'),
    
    # Tenant preferences
    path('reminder-preferences/', UpdateReminderPreferencesView.as_view(), name='update-reminder-preferences'),
    
    # Available units
    path('available-units/', LandlordAvailableUnitsView.as_view(), name='available-units'),
    
    # Tenants & Landlords
    path('tenants/', UserListView.as_view(), name='tenant-list'),  # ✅ ADD THIS (alias to users)
    path('landlords/profile/', LandlordProfileView.as_view(), name='landlord-profile'),  # ✅ ADD THIS
    
    # Landlord validation for tenant signup
    path('validate-landlord/', ValidateLandlordView.as_view(), name='validate-landlord'),  # ✅ ADD THIS
    
    # Registration steps
    path('tenant/register/step/<int:step>/', TenantRegistrationStepView.as_view(), name='tenant-register-step'),
    path('tenant/register/complete/', CompleteTenantRegistrationView.as_view(), name='tenant-register-complete'),
    path('landlord/register/step/<int:step>/', LandlordRegistrationStepView.as_view(), name='landlord-register-step'),
    path('landlord/register/complete/', CompleteLandlordRegistrationView.as_view(), name='landlord-register-complete'),
    
    # Admin views
    path('admin/landlords/', LandlordsListView.as_view(), name='admin-landlords'),
    path('admin/subscription-status/', AdminLandlordSubscriptionStatusView.as_view(), name='admin-subscription-status'),
    path('applications/pending/', PendingApplicationsView.as_view(), name='pending-applications'),
    path('tenants/evicted/', EvictedTenantsView.as_view(), name='evicted-tenants'),
    
    # Welcome
    path('welcome/', WelcomeView.as_view(), name='welcome'),
]
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status, generics,permissions
from accounts.serializers import (
    PropertySerializer,
    UnitSerializer,
    UnitNumberSerializer,
    UserSerializer,
    PasswordResetSerializer,
    PasswordResetConfirmSerializer,
    TenantWithUnitSerializer,
    ReminderPreferencesSerializer,
    LandlordDashboardSerializer,
    CustomUserSerializer,
    AvailableUnitsSerializer,
)
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from django.core.cache import cache
from .models import Property, Unit, CustomUser, Subscription, UnitType,TenantProfile
from payments.models import Payment
from django.shortcuts import get_object_or_404
from .permissions import IsLandlord, IsTenant, IsSuperuser, HasActiveSubscription
from communication.models import Report
from communication.serializers import ReportSerializer
from django.core.exceptions import ValidationError

import logging

import uuid

logger = logging.getLogger(__name__)

from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Count, Sum, Q
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal

# accounts/views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import MyTokenObtainPairSerializer
from .serializers import UnitTypeSerializer

class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer


# In your Django views.py - UnitTypeListCreateView should handle POST requests
class UnitTypeListCreateView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        print("📊 GET: Fetching unit types for user:", request.user.id)
        try:
            unit_types = UnitType.objects.filter(landlord=request.user)
            print(f"📊 Found {unit_types.count()} unit types")
            serializer = UnitTypeSerializer(unit_types, many=True)
            return Response(serializer.data)
        except Exception as e:
            print(f"❌ Error fetching unit types: {str(e)}")
            return Response({"error": "Failed to fetch unit types"}, status=500)

    def post(self, request):
        print("📝 POST: Creating unit type for user:", request.user.id)
        print("📝 Request data:", request.data)
        
        try:
            # Create the unit type manually - bypass serializer for creation
            unit_type = UnitType.objects.create(
                landlord=request.user,  # Set landlord directly
                name=request.data.get('name'),
                rent=request.data.get('rent'),
                deposit=request.data.get('deposit', 0),
                description=request.data.get('description', ''),
                number_of_units=0  # Default value
            )
            print(f"✅ Unit type created: {unit_type.id} - {unit_type.name}")
            
            # Serialize the created object for response
            serializer = UnitTypeSerializer(unit_type)
            return Response(serializer.data, status=201)
                
        except Exception as e:
            print(f"❌ Unexpected error in unit type creation: {str(e)}")
            import traceback
            traceback.print_exc()
            return Response({"error": "Internal server error"}, status=500)
    
    def create_units_for_unit_type(self, property_obj, unit_type, unit_count):
        """Create multiple units for a given unit type"""
        # Get existing units to determine next unit number
        existing_units = Unit.objects.filter(property_obj=property_obj)
        last_unit = existing_units.order_by('-unit_number').first()

        if last_unit and last_unit.unit_number.isdigit():
            start_number = int(last_unit.unit_number) + 1
        else:
            start_number = 1

        units_created = []
        for i in range(unit_count):
            unit_number = start_number + i
            unit_code = f"U-{property_obj.id}-{unit_type.name.replace(' ', '-')}-{unit_number}"

            unit = Unit.objects.create(
                property_obj=property_obj,
                unit_code=unit_code,
                unit_number=str(unit_number),
                unit_type=unit_type,
                is_available=True,
                rent=unit_type.rent,
                deposit=unit_type.deposit,
            )
            units_created.append(unit)

        # Invalidate caches after creating units
        cache.delete(f"landlord:{unit_type.landlord.id}:properties")
        cache.delete(f"property:{property_obj.id}:units")

        return units_created

class LandlordDashboardStatsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        landlord = request.user

        # Total active tenants: tenants assigned to units of this landlord and active
        total_active_tenants = CustomUser.objects.filter(
            user_type='tenant',
            is_active=True,
            unit__property_obj__landlord=landlord
        ).distinct().count()

        # Total units available
        total_units_available = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=True
        ).count()

        # Total units occupied
        total_units_occupied = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=False
        ).count()

        # Monthly revenue: sum of successful rent payments in the current month for this landlord
        now = timezone.now()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        # Use created_at field instead of transaction_date
        monthly_revenue_agg = Payment.objects.filter(
            unit__property_obj__landlord=landlord,
            payment_type='rent',
            status='Success',
            created_at__gte=start_of_month,  # Changed from transaction_date
            created_at__lte=now  # Changed from transaction_date
        ).aggregate(total=Sum('amount'))
        monthly_revenue = monthly_revenue_agg['total'] or 0

        data = {
            "total_active_tenants": total_active_tenants,
            "total_units_available": total_units_available,
            "total_units_occupied": total_units_occupied,
            "monthly_revenue": float(monthly_revenue),
        }

        return Response(data)


class UnitTypeDetailView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get_object(self, pk, user):
        return UnitType.objects.get(id=pk, landlord=user)

    def get(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut)
            return Response(serializer.data)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def put(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def delete(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            ut.delete()
            return Response({"message": "UnitType deleted"}, status=200)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)


# Lists a single user (cached)
# View to get user details
class UserDetailView(APIView):
    permission_classes = [IsAuthenticated, HasActiveSubscription]

    def get(self, request, user_id):
        cache_key = f"user:{user_id}"
        user_data = cache.get(cache_key)

        if not user_data:
            try:
                user = CustomUser.objects.get(id=user_id)
                serializer = UserSerializer(user)
                user_data = serializer.data
                cache.set(cache_key, user_data, timeout=300)  # cache for 5 minutes
            except CustomUser.DoesNotExist:
                return Response({"error": "User not found"}, status=404)

        return Response(user_data)


# New admin view to list landlords and their subscription statuses (superuser only)
class AdminLandlordSubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'landlord_id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


# Lists all tenants (cached)
# View to list all tenants (landlord only)
class UserListView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        # Get only tenants associated with this landlord
        tenants = request.user.my_tenants
        serializer = UserSerializer(tenants, many=True)
        return Response(serializer.data)

# Create a new user (invalidate cache)
# View to create a new user Landlord or Tenant
class UserCreateView(APIView):
    def post(self, request):
        print("Signup request received:", request.data)  # Debug logging
        
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            print(f"User created successfully: {user.email}, ID: {user.id}")  # Debug logging

            # Landlord onboarding: optionally auto-create properties and units if provided
            if user.user_type == 'landlord':
                # Expect optional 'properties' array in request.data, each item: {name, city, state, unit_count, vacant_units}
                properties = request.data.get('properties')
                from .models import Property, Unit, UnitType
                import uuid

                if properties and isinstance(properties, list):
                    for prop in properties:
                        name = prop.get('name') or f"Property-{uuid.uuid4().hex[:6].upper()}"
                        city = prop.get('city', '')
                        state = prop.get('state', '')
                        unit_count = int(prop.get('unit_count', 0))
                        p = Property.objects.create(landlord=user, name=name, city=city, state=state, unit_count=unit_count)

                        # Create at least one unit if unit_count > 0
                        for i in range(1, unit_count + 1):
                            unit_number = str(i)
                            unit_code = f"U-{p.id}-{i}"
                            # Determine vacancy status based on optional vacant_units or default all vacant
                            vacant_units = int(prop.get('vacant_units', unit_count))
                            is_available = i <= vacant_units

                            # Optionally link to a unit_type if provided via name
                            unit_type_obj = None
                            unit_type_name = prop.get('unit_type')
                            if unit_type_name:
                                unit_type_obj, _ = UnitType.objects.get_or_create(landlord=user, name=unit_type_name)

                            Unit.objects.create(
                                property_obj=p,
                                unit_code=unit_code,
                                unit_number=unit_number,
                                unit_type=unit_type_obj,
                                is_available=is_available,
                                rent=unit_type_obj.rent if unit_type_obj else 0,
                                deposit=unit_type_obj.deposit if unit_type_obj else 0,
                            )

            # Tenant created: attempt to assign unit if landlord_code and unit_code provided
            if user.user_type == "tenant":
                cache.delete("tenants:list")
                landlord_code = request.data.get('landlord_code')
                unit_code = request.data.get('unit_code')
                if landlord_code and unit_code:
                    try:
                        landlord = CustomUser.objects.get(landlord_code=landlord_code, user_type='landlord')
                        unit = Unit.objects.get(unit_code=unit_code, property_obj__landlord=landlord)
                        # Check for deposit payments
                        from payments.models import Payment
                        deposit_payments = Payment.objects.filter(
                            tenant=user,
                            unit=unit,
                            payment_type='deposit',
                            status='Success',
                            amount__gte=unit.deposit
                        )
                        if deposit_payments.exists():
                            unit.tenant = user
                            unit.is_available = False
                            unit.save()
                        else:
                            # leave unassigned; frontend should request deposit
                            pass
                    except CustomUser.DoesNotExist:
                        # landlord not found; ignore
                        pass
                    except Unit.DoesNotExist:
                        pass

            return Response(serializer.data, status=201)
        else:
            print("Serializer errors:", serializer.errors)  # Debug logging
            return Response(serializer.errors, status=400)


# Create a new property (invalidate landlord cache)
# View to create a new property (landlord only)
PLAN_LIMITS = {
    "free": 2,         # trial landlords can only create 2 properties
    "starter": 3,      # starter (up to 10 units) -> small number of properties
    "basic": 10,       # basic (10-50 units)
    "professional": 25,# professional (50-100 units)
    "onetime": None,   # unlimited
}

class CreatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        logger.info(f"CreatePropertyView: User {request.user.id} attempting to create property")
        user = request.user

        # Fetch subscription
        try:
            subscription = Subscription.objects.get(user=user)
            logger.info(f"Subscription found: {subscription.plan}")
        except Subscription.DoesNotExist:
            logger.error(f"No subscription found for user {user.id}")
            return Response({"error": "No active subscription found."}, status=403)

        plan = subscription.plan.lower()

        # Check if subscription is active
        if not subscription.is_active():
            logger.warning(f"Subscription expired for user {user.id}")
            return Response({"error": "Your subscription has expired. Please renew or upgrade."}, status=403)

        # Get plan limit
        max_properties = PLAN_LIMITS.get(plan)
        if max_properties is None and plan != "onetime":
            return Response({"error": f"Unknown plan type: {plan}"}, status=400)

        # Count current properties
        current_count = Property.objects.filter(landlord=user).count()
        logger.info(f"Current properties count: {current_count}, max: {max_properties}")
        if plan != "onetime" and current_count >= max_properties:
            return Response({
                "error": f"Your current plan ({plan}) allows a maximum of {max_properties} properties. Upgrade to add more."
            }, status=403)

        # Proceed with creation
        serializer = PropertySerializer(data=request.data)
        if serializer.is_valid():
            logger.info(f"Serializer valid, saving property for user {user.id}")
            property = serializer.save(landlord=user)
            try:
                cache.delete(f"landlord:{user.id}:properties")  # clear cache if you're caching landlord properties
                logger.info(f"Cache cleared for user {user.id}")
            except Exception as e:
                logger.warning(f"Cache delete failed: {e}")
            logger.info(f"Property created successfully: {property.id}")
            return Response(serializer.data, status=201)

        logger.error(f"Serializer errors: {serializer.errors}")
        return Response(serializer.errors, status=400)

# List landlord properties (cached)
class LandlordPropertiesView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = f"landlord:{request.user.id}:properties"
        properties_data = cache.get(cache_key)

        if not properties_data:
            properties = Property.objects.filter(landlord=request.user)
            serializer = PropertySerializer(properties, many=True)
            properties_data = serializer.data
            cache.set(cache_key, properties_data, timeout=300)

        return Response(properties_data)


# Create a new unit (invalidate landlord cache)
# In your Django views.py - Update CreateUnitView
class CreateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        print("CreateUnitView: Received data:", request.data)  # Debug logging
        
        try:
            # Validate that the property belongs to the landlord
            property_id = request.data.get('property_obj')
            if not property_id:
                return Response({"error": "Property is required"}, status=400)
                
            try:
                property_obj = Property.objects.get(id=property_id, landlord=request.user)
            except Property.DoesNotExist:
                return Response({"error": "Property not found or you do not have permission"}, status=404)

            # Validate unit number
            unit_number = request.data.get('unit_number')
            if not unit_number:
                return Response({"error": "Unit number is required"}, status=400)

            # Check if unit number already exists in this property
            if Unit.objects.filter(property_obj=property_obj, unit_number=unit_number).exists():
                return Response({"error": f"Unit number {unit_number} already exists in this property"}, status=400)

            # Generate unique unit code
            unit_code = f"U-{property_obj.id}-{unit_number}-{uuid.uuid4().hex[:8]}"
            
            # Prepare unit data
            unit_data = {
                'property_obj': property_obj.id,
                'unit_code': unit_code,
                'unit_number': unit_number.strip(),
                'unit_type': request.data.get('unit_type'),
                'bedrooms': request.data.get('bedrooms', 0),
                'bathrooms': request.data.get('bathrooms', 1),
                'floor': request.data.get('floor', 0),
                'rent': request.data.get('rent', 0),
                'deposit': request.data.get('deposit', 0),
                'is_available': True
            }

            print("CreateUnitView: Processed unit data:", unit_data)  # Debug logging

            serializer = UnitSerializer(data=unit_data, context={'request': request})
            
            if serializer.is_valid():
                print("CreateUnitView: Serializer is valid")  # Debug logging
                unit = serializer.save()
                
                # Invalidate caches
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{unit.property_obj.id}:units")
                
                print(f"CreateUnitView: Unit created successfully - ID: {unit.id}")  # Debug logging
                
                return Response(serializer.data, status=201)
            else:
                print("CreateUnitView: Serializer errors:", serializer.errors)  # Debug logging
                return Response(serializer.errors, status=400)
                
        except Exception as e:
            print(f"CreateUnitView: Unexpected error: {str(e)}")  # Debug logging
            return Response({"error": "Internal server error while creating unit"}, status=500)


# List units of a property (cached)
class PropertyUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"property:{property_id}:units"
        units_data = cache.get(cache_key)

        if not units_data:
            try:
                property = Property.objects.get(id=property_id, landlord=request.user)
                units = Unit.objects.filter(property_obj=property)
                serializer = UnitSerializer(units, many=True)
                units_data = serializer.data
                cache.set(cache_key, units_data, timeout=300)
            except Property.DoesNotExist:
                return Response(
                    {"error": "Property not found or you do not have permission"},
                    status=404,
                )

        return Response(units_data)


# Assign tenant to unit (invalidate cache)
# In your Django views.py - Update the AssignTenantView if needed
class AssignTenantView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    @method_decorator(csrf_exempt)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def post(self, request, unit_id, tenant_id):
        logger.info(f"AssignTenantView: Landlord {request.user.id} attempting to assign tenant {tenant_id} to unit {unit_id}")

        try:
            # Validate unit exists and belongs to landlord
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            logger.info(f"Unit found: {unit.unit_code}, available: {unit.is_available}, current tenant: {unit.tenant}")

            # Check if unit is available
            if unit.tenant is not None:
                logger.warning(f"Unit {unit_id} already has tenant {unit.tenant.id} assigned")
                return Response({
                    "error": f"Unit is already assigned to {unit.tenant.full_name}",
                    "status": "failed"
                }, status=400)

            if not unit.is_available:
                logger.warning(f"Unit {unit_id} is marked as not available")
                return Response({
                    "error": "Unit is not available for assignment",
                    "status": "failed"
                }, status=400)

            # Validate tenant exists and is a tenant
            tenant = CustomUser.objects.get(id=tenant_id, user_type="tenant")
            logger.info(f"Tenant found: {tenant.full_name} (ID: {tenant.id})")

            # Check if tenant already has a unit assigned
            existing_unit = Unit.objects.filter(tenant=tenant).first()
            if existing_unit:
                logger.warning(f"Tenant {tenant_id} already has unit {existing_unit.id} assigned")
                return Response({
                    "error": f"Tenant already has unit {existing_unit.unit_number} assigned. Please remove them from their current unit first.",
                    "status": "failed"
                }, status=400)

            # Assign tenant to unit
            unit.tenant = tenant
            unit.is_available = False
            unit.assigned_date = timezone.now()
            unit.save()

            # Create or update tenant profile
            TenantProfile.objects.update_or_create(
                tenant=tenant,
                defaults={
                    'current_unit': unit,
                    'landlord': request.user,
                    'move_in_date': timezone.now()
                }
            )

            # Invalidate caches
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")

            logger.info(f"✅ Tenant {tenant.full_name} assigned to unit {unit.unit_number}")

            return Response({
                'message': f'Tenant {tenant.full_name} successfully assigned to unit {unit.unit_number}',
                'status': 'success',
                'unit': {
                    'id': unit.id,
                    'unit_number': unit.unit_number,
                    'property_name': unit.property_obj.name
                }
            }, status=200)

        except Unit.DoesNotExist:
            logger.error(f"Unit {unit_id} not found or not owned by landlord {request.user.id}")
            return Response({
                "error": "Unit not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except CustomUser.DoesNotExist:
            logger.error(f"Tenant {tenant_id} not found or invalid user type")
            return Response({
                "error": "Tenant not found or invalid user type",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in AssignTenantView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)
         
class RemoveTenantFromUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request, unit_id):
        logger.info(f"RemoveTenantFromUnitView: Landlord {request.user.id} removing tenant from unit {unit_id}")

        try:
            # Validate unit exists and belongs to landlord
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            logger.info(f"Unit found: {unit.unit_code}, current tenant: {unit.tenant}")

            if unit.tenant is None:
                logger.warning(f"Unit {unit_id} has no tenant assigned")
                return Response({
                    "error": "Unit has no tenant assigned",
                    "status": "failed"
                }, status=400)

            tenant_name = unit.tenant.full_name
            tenant_id = unit.tenant.id

            # Remove tenant from unit
            unit.tenant = None
            unit.is_available = True
            unit.assigned_date = None
            unit.save()

            # Invalidate caches
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")

            logger.info(f"✅ Tenant {tenant_name} removed from unit {unit.unit_number}")

            return Response({
                'message': f'Tenant {tenant_name} successfully removed from unit {unit.unit_number}',
                'status': 'success',
                'unit': {
                    'id': unit.id,
                    'unit_number': unit.unit_number,
                    'property_name': unit.property_obj.name
                }
            }, status=200)

        except Unit.DoesNotExist:
            logger.error(f"Unit {unit_id} not found or not owned by landlord {request.user.id}")
            return Response({
                "error": "Unit not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in RemoveTenantFromUnitView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)

# Password reset
class PasswordResetView(APIView):
    def post(self, request):
        serializer = PasswordResetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(
                {"message": "Password reset email sent."}, status=status.HTTP_200_OK
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
# Update property
class UpdatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            serializer = PropertySerializer(property, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{property_id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

    def delete(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            property.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Property deleted successfully."}, status=200)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

# Update unit
class UpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            serializer = UnitSerializer(unit, data=request.data, partial=True, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)

    def delete(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            property_id = unit.property_obj.id
            unit.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Unit deleted successfully."}, status=200)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)


class TenantUpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def put(self, request):
        try:
            unit = Unit.objects.get(tenant=request.user)
            serializer = UnitNumberSerializer(unit, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "No unit assigned to you"}, status=404)

# Update user
class UpdateUserView(APIView):  
    permission_classes = [IsAuthenticated]

    def put(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to update this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            serializer = UserSerializer(user, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"user:{user_id}")
                if user.user_type == "tenant":
                    cache.delete("tenants:list")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)

    def delete(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to delete this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            user.delete()
            cache.delete(f"user:{user_id}")
            if user.user_type == "tenant":
                cache.delete("tenants:list")
            return Response({"message": "User deleted successfully."}, status=200)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)


class AdjustRentView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        landlord = request.user
        adjustment_type = request.data.get('adjustment_type')  # 'percentage' or 'fixed'
        value = request.data.get('value')  # decimal, positive for increase, negative for decrease
        unit_type_id = request.data.get('unit_type_id')  # optional, if provided, adjust only units of this type

        logger.info(f"AdjustRentView POST: Landlord {landlord.id} adjusting rent, adjustment_type={adjustment_type}, value={value}, unit_type_id={unit_type_id}")

        if adjustment_type not in ['percentage', 'fixed']:
            return Response({"error": "adjustment_type must be 'percentage' or 'fixed'"}, status=400)

        try:
            value = Decimal(value)
        except (ValueError, TypeError):
            return Response({"error": "value must be a valid number"}, status=400)

        # Filter units
        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            old_rent = unit.rent
            if adjustment_type == 'percentage':
                new_rent = old_rent * (Decimal(1) + value / Decimal(100))
            else:  # fixed
                new_rent = old_rent + value
            # Ensure rent doesn't go negative
            new_rent = max(Decimal(0), new_rent)
            unit.rent = new_rent
            unit.save()  # This will update rent_remaining
            updated_count += 1

        logger.info(f"AdjustRentView POST: Rent adjusted for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        # Also invalidate rent_summary cache
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent adjusted for {updated_count} units successfully"})

    def put(self, request):
        landlord = request.user
        new_rent = request.data.get('new_rent')
        unit_type_id = request.data.get('unit_type_id')  # optional

        logger.info(f"AdjustRentView PUT: Landlord {landlord.id} setting new rent, new_rent={new_rent}, unit_type_id={unit_type_id}")

        if new_rent is None:
            return Response({"error": "new_rent is required"}, status=400)

        try:
            new_rent = Decimal(new_rent)
        except (ValueError, TypeError):
            return Response({"error": "new_rent must be a valid number"}, status=400)

        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            unit.rent = new_rent
            unit.save()
            updated_count += 1

        logger.info(f"AdjustRentView PUT: Rent set to {new_rent} for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent set to {new_rent} for {updated_count} units successfully"})

# View to check subscription status (landlord only)
class SubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord]

    def get(self, request):
        user = request.user
        try:
            subscription = Subscription.objects.get(user=user)
            data = {
                "plan": subscription.plan,
                "is_active": subscription.is_active(),
                "expiry_date": subscription.expiry_date,
                "status": "Subscribed" if subscription.is_active() else "Inactive"
            }
        except Subscription.DoesNotExist:
            data = {"status": "No subscription found"}
        return Response(data)

# View to update landlord's Mpesa till number (landlord only)
class UpdateTillNumberView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def patch(self, request):
        user = request.user
        till_number = request.data.get('mpesa_till_number')
        if not till_number:
            return Response({"error": "mpesa_till_number is required"}, status=400)

        user.mpesa_till_number = till_number
        user.save()
        return Response({"message": "Till number updated successfully", "mpesa_till_number": till_number})

    def put(self, request):
        return self.patch(request)


# Endpoint to get or update the currently authenticated user
class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

    def patch(self, request):
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            # invalidate cache for this user
            cache.delete(f"user:{request.user.id}")
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

    def put(self, request):
        return self.patch(request)


# View to update tenant reminder preferences
class UpdateReminderPreferencesView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def patch(self, request):
        serializer = ReminderPreferencesSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)


# Password reset confirm view
class PasswordResetConfirmView(APIView):
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Password has been reset successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# View to list available units for landlords to share with tenants
class LandlordAvailableUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        units = Unit.objects.filter(property_obj__landlord=request.user, is_available=True)
        serializer = AvailableUnitsSerializer(units, many=True)
        return Response(serializer.data)


# New endpoint to log requests and return a welcome message
class WelcomeView(APIView):
    def get(self, request):
        logger.info(f"Request received: {request.method} {request.path}")
        return Response({"message": "Welcome to the Makau Rentals API!"})


class LandlordsListView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


class PendingApplicationsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        # For now, return tenants without assigned units (pending applications)
        tenants = CustomUser.objects.filter(
            user_type="tenant",
            is_active=True,
            unit__isnull=True
        )
        serializer = UserSerializer(tenants, many=True)
        return Response(serializer.data)


class EvictedTenantsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        # For now, return inactive tenants that were previously assigned to landlord's units
        evicted_tenants = CustomUser.objects.filter(
            user_type="tenant",
            is_active=False,
            unit__property_obj__landlord=request.user
        ).distinct()
        serializer = UserSerializer(evicted_tenants, many=True)
        return Response(serializer.data)
# Add this view to your views.py to validate and fetch landlord data

class ValidateLandlordView(APIView):
    """Endpoint to validate landlord ID and fetch their properties"""
    
    def post(self, request):
        landlord_code = request.data.get('landlord_code')
        
        print(f"🔍 Validating landlord with code: {landlord_code}")  # DEBUG
        
        if not landlord_code:
            return Response({
                'error': 'Landlord code is required'
            }, status=400)
        
        try:
            # Find landlord by landlord_code
            landlord = CustomUser.objects.get(
                landlord_code=landlord_code,
                user_type='landlord',
                is_active=True
            )
            
            print(f"✅ Landlord found: {landlord.full_name} (ID: {landlord.id})")  # DEBUG
            
            # Get properties for this landlord
            properties = Property.objects.filter(landlord=landlord)
            print(f"📊 Found {properties.count()} properties for landlord")  # DEBUG
            
            properties_data = []
            for property_obj in properties:
                print(f"🏠 Processing property: {property_obj.name} (ID: {property_obj.id})")  # DEBUG
                
                # Get available units for this property
                try:
                    # Try different related names
                    available_units = None
                    
                    if hasattr(property_obj, 'units'):
                        available_units = property_obj.units.filter(
                            is_available=True,
                            tenant__isnull=True
                        )
                        print(f"   Using 'units' related name, found {available_units.count()} available units")  # DEBUG
                    elif hasattr(property_obj, 'unit_set'):
                        available_units = property_obj.unit_set.filter(
                            is_available=True,
                            tenant__isnull=True
                        )
                        print(f"   Using 'unit_set' related name, found {available_units.count()} available units")  # DEBUG
                    else:
                        # Fallback: direct query
                        available_units = Unit.objects.filter(
                            property_obj=property_obj,
                            is_available=True,
                            tenant__isnull=True
                        )
                        print(f"   Using direct query, found {available_units.count()} available units")  # DEBUG
                        
                except Exception as e:
                    print(f"   ❌ Error accessing units: {e}")  # DEBUG
                    continue
                
                if available_units and available_units.exists():
                    units_data = []
                    for unit in available_units:
                        unit_data = {
                            'id': unit.id,
                            'unit_number': unit.unit_number,
                            'unit_code': unit.unit_code,
                            'rent': float(unit.rent),
                            'deposit': float(unit.deposit),
                        }
                        
                        # Add room type info if available
                        if hasattr(unit, 'unit_type') and unit.unit_type:
                            unit_data['room_type'] = unit.unit_type.name
                        else:
                            unit_data['room_type'] = 'N/A'
                            
                        # Add bedroom/bathroom info
                        if hasattr(unit, 'bedrooms'):
                            unit_data['bedrooms'] = unit.bedrooms
                        else:
                            unit_data['bedrooms'] = 0
                            
                        if hasattr(unit, 'bathrooms'):
                            unit_data['bathrooms'] = unit.bathrooms
                        else:
                            unit_data['bathrooms'] = 1
                        
                        units_data.append(unit_data)
                        print(f"   ✅ Added unit: {unit.unit_number}")  # DEBUG
                    
                    properties_data.append({
                        'id': property_obj.id,
                        'name': property_obj.name,
                        'address': f"{getattr(property_obj, 'city', '')}, {getattr(property_obj, 'state', '')}",
                        'units': units_data
                    })
                    print(f"   🏢 Added property with {len(units_data)} units")  # DEBUG
                else:
                    print(f"   ⚠️  No available units for property {property_obj.name}")  # DEBUG
            
            print(f"📦 Final properties data: {len(properties_data)} properties with available units")  # DEBUG
            
            if not properties_data:
                return Response({
                    'error': 'This landlord has no available units at the moment'
                }, status=404)
            
            return Response({
                'landlord_id': landlord.id,
                'landlord_name': landlord.full_name,
                'landlord_email': landlord.email,
                'landlord_phone': getattr(landlord, 'phone_number', ''),
                'properties': properties_data
            }, status=200)
            
        except CustomUser.DoesNotExist:
            print(f"❌ Landlord not found with code: {landlord_code}")  # DEBUG
            return Response({
                'error': 'Landlord ID not found. Please check and try again.'
            }, status=404)
        except Exception as e:
            print(f"💥 Unexpected error: {str(e)}")  # DEBUG
            logger.error(f"Error in ValidateLandlordView: {str(e)}")
            return Response({
                'error': 'Internal server error while validating landlord'
            }, status=500)


# Update your TenantRegistrationStepView to handle Step 2 validation
class TenantRegistrationStepView(APIView):
    def post(self, request, step):
        try:
            data = request.data.copy()  # Make a copy to avoid mutating original
            session_id = data.get('session_id') or str(uuid.uuid4())
            
            # STEP 2: Validate landlord ID before saving
            if step == 2:
                landlord_id = data.get('landlord_id')
                if landlord_id:
                    try:
                        # Verify landlord exists and is active
                        landlord = CustomUser.objects.get(
                            landlord_code=landlord_id,
                            user_type='landlord',
                            is_active=True
                        )
                        
                        # Add landlord info to cached data
                        data['landlord_db_id'] = landlord.id
                        data['verified'] = True
                        
                    except CustomUser.DoesNotExist:
                        return Response({
                            'error': 'Landlord ID not found. Please check and try again.',
                            'status': 'failed'
                        }, status=400)
            
            # Store step data in cache
            cache_key = f"tenant_registration_{session_id}_step_{step}"
            cache.set(cache_key, data, timeout=3600)  # 1 hour expiry
            
            return Response({
                'session_id': session_id,  # Make sure this is returned
                'step': step,
                'status': 'saved',
                'message': f'Step {step} data saved successfully'
            })
            
        except Exception as e:
            logger.error(f"Error in TenantRegistrationStepView: {str(e)}")
            return Response({
                'error': 'Internal server error',
                'status': 'failed'
            }, status=500)
        
class LandlordRegistrationStepView(APIView):
    def post(self, request, step):
        data = request.data
        session_id = data.get('session_id') or str(uuid.uuid4())
        
        # Store step data in cache
        cache_key = f"landlord_registration_{session_id}_step_{step}"
        cache.set(cache_key, data, timeout=3600)
        
        return Response({
            'session_id': session_id,
            'step': step,
            'status': 'saved',
            'message': f'Step {step} data saved successfully'
        })

class CompleteTenantRegistrationView(APIView):
    def post(self, request):
        """
        Complete tenant registration after all steps are done
        """
        try:
            data = request.data
            session_id = data.get('session_id')

            if not session_id:
                return Response({
                    'status': 'error',
                    'message': 'Session ID is required'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Retrieve all step data from cache
            all_data = {}
            for step in range(2, 7):  # Steps 2-6
                cache_key = f"tenant_registration_{session_id}_step_{step}"
                step_data = cache.get(cache_key)
                if step_data:
                    all_data.update(step_data)

            # Merge with final data
            all_data.update(data)

            # Validate required fields
            required_fields = ['email', 'full_name', 'password', 'phone_number',
                             'national_id', 'emergency_contact']

            missing_fields = [field for field in required_fields if not all_data.get(field)]
            if missing_fields:
                return Response({
                    'status': 'error',
                    'message': f'Missing required fields: {", ".join(missing_fields)}'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Check if email already exists
            if CustomUser.objects.filter(email=all_data['email']).exists():
                return Response({
                    'status': 'error',
                    'message': 'Email already exists'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Create the tenant user
            try:
                user = CustomUser.objects.create_user(
                    email=all_data['email'],
                    full_name=all_data['full_name'],
                    user_type='tenant',
                    password=all_data['password'],
                    phone_number=all_data['phone_number'],
                    national_id=all_data['national_id'],
                    emergency_contact=all_data['emergency_contact']
                )

                logger.info(f"✅ Tenant user created: {user.email} (ID: {user.id})")

                # Landlord onboarding: assign unit if landlord_code and unit_code provided
                landlord_code = all_data.get('landlord_id') or all_data.get('landlord_code')
                unit_code = all_data.get('unit_code')

                if landlord_code and unit_code:
                    try:
                        landlord = CustomUser.objects.get(
                            landlord_code=landlord_code,
                            user_type='landlord',
                            is_active=True
                        )
                        unit = Unit.objects.get(
                            unit_code=unit_code,
                            property_obj__landlord=landlord
                        )

                        # Check for deposit payments
                        from payments.models import Payment
                        deposit_payments = Payment.objects.filter(
                            tenant=user,
                            unit=unit,
                            payment_type='deposit',
                            status='Success',
                            amount__gte=unit.deposit
                        )

                        if deposit_payments.exists():
                            unit.tenant = user
                            unit.is_available = False
                            unit.save()

                            # Create tenant profile
                            TenantProfile.objects.update_or_create(
                                tenant=user,
                                defaults={
                                    'current_unit': unit,
                                    'landlord': landlord,
                                    'move_in_date': timezone.now()
                                }
                            )

                            logger.info(f"✅ Tenant {user.full_name} assigned to unit {unit.unit_number}")
                        else:
                            logger.info(f"ℹ️  Tenant {user.full_name} created but no deposit payment found for unit assignment")

                    except CustomUser.DoesNotExist:
                        logger.warning(f"Landlord with code {landlord_code} not found")
                    except Unit.DoesNotExist:
                        logger.warning(f"Unit with code {unit_code} not found")
                    except Exception as assign_error:
                        logger.error(f"Error assigning tenant to unit: {str(assign_error)}")

                # Clean up cache
                for step in range(2, 7):
                    cache_key = f"tenant_registration_{session_id}_step_{step}"
                    cache.delete(cache_key)

                return Response({
                    'status': 'success',
                    'user_id': user.id,
                    'email': user.email,
                    'full_name': user.full_name,
                    'message': 'Tenant registration completed successfully'
                }, status=status.HTTP_201_CREATED)

            except ValidationError as e:
                return Response({
                    'status': 'error',
                    'message': str(e)
                }, status=status.HTTP_400_BAD_REQUEST)

            except Exception as e:
                logger.error(f"Error creating tenant user: {str(e)}")
                # If user creation fails but user was created, delete it
                if 'user' in locals():
                    user.delete()
                return Response({
                    'status': 'error',
                    'message': 'Failed to create tenant account'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            logger.error(f"Unexpected error in tenant registration: {str(e)}")
            return Response({
                'status': 'error',
                'message': 'Internal server error'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
class CompleteLandlordRegistrationView(APIView):
    def post(self, request):
        """
        Complete landlord registration after all steps are done
        """
        try:
            data = request.data
            session_id = data.get('session_id')
            
            if not session_id:
                return Response({
                    'status': 'error',
                    'message': 'Session ID is required'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Retrieve all step data from cache
            all_data = {}
            for step in range(2, 5):
                cache_key = f"landlord_registration_{session_id}_step_{step}"
                step_data = cache.get(cache_key)
                if step_data:
                    step_data.pop('step', None)
                    all_data.update(step_data)

            all_data.update(data)
            
            # Validate required fields (only essential ones for landlord creation)
            required_fields = ['full_name', 'email', 'password']

            missing_fields = [field for field in required_fields if not all_data.get(field)]
            if missing_fields:
                return Response({
                    'status': 'error',
                    'message': f'Missing required fields: {", ".join(missing_fields)}'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Check if email already exists
            if CustomUser.objects.filter(email=all_data['email']).exists():
                return Response({
                    'status': 'error',
                    'message': 'Email already exists'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Create the landlord user
            try:
                user_data = {
                    'email': all_data['email'],
                    'full_name': all_data['full_name'],
                    'user_type': 'landlord',
                    'password': all_data['password'],
                    'phone_number': all_data['phone_number'],
                    'national_id': all_data['national_id'],
                    'mpesa_till_number': all_data['mpesa_till_number'],
                }
                
                # Add optional fields if they exist
                if 'address' in all_data:
                    user_data['address'] = all_data['address']
                if 'website' in all_data:
                    user_data['website'] = all_data['website']

                landlord = CustomUser.objects.create_user(**user_data)

                # Create properties and units if provided
                properties_data = all_data.get('properties', [])
                created_properties = []
                
                for property_data in properties_data:
                    try:
                        # Create property
                        property_obj = Property.objects.create(
                            landlord=landlord,
                            name=property_data.get('name', f'Property-{uuid.uuid4().hex[:6].upper()}'),
                            city='Nairobi',
                            state='Nairobi',
                            unit_count=len(property_data.get('units', []))
                        )
                        
                        # Create units for this property
                        units_data = property_data.get('units', [])
                        created_units = []
                        
                        for i, unit_data in enumerate(units_data, 1):
                            # Create unit type if it doesn't exist
                            room_type = unit_data.get('room_type', 'studio')
                            unit_type, created = UnitType.objects.get_or_create(
                                landlord=landlord,
                                name=room_type,
                                defaults={
                                    'deposit': Decimal('0.00'),
                                    'rent': Decimal(unit_data.get('monthlyRent', '0')),
                                    'number_of_units': 0
                                }
                            )
                            
                            # Generate unique unit code
                            unit_number = unit_data.get('unitNumber', f'Unit-{i}')
                            unit_code = f"U-{property_obj.id}-{unit_number}-{uuid.uuid4().hex[:8]}"
                            
                            # Create the unit
                            unit = Unit.objects.create(
                                property_obj=property_obj,
                                unit_code=unit_code,  # Use the unique generated code
                                unit_number=unit_number,
                                bedrooms=self.get_bedroom_count(room_type),
                                bathrooms=1,
                                unit_type=unit_type,
                                rent=Decimal(unit_data.get('monthlyRent', '0')),
                                deposit=Decimal(unit_data.get('monthlyRent', '0')),  # Deposit = 1 month rent
                                is_available=True
                            )
                            created_units.append(unit.id)
                        
                        created_properties.append({
                            'id': property_obj.id,
                            'name': property_obj.name,
                            'units_count': len(created_units)
                        })
                        
                    except Exception as prop_error:
                        logger.error(f"Error creating property: {str(prop_error)}")
                        continue

                # FIX 2: Check if subscription already exists before creating
                try:
                    subscription = Subscription.objects.get(user=landlord)
                    # Subscription already exists (was created by CustomUserManager)
                    logger.info(f"Subscription already exists for user {landlord.id}")
                except Subscription.DoesNotExist:
                    # Create subscription for landlord (free trial)
                    subscription = Subscription.objects.create(
                        user=landlord,
                        plan="free",
                        expiry_date=timezone.now() + timedelta(days=60)
                    )
                    logger.info(f"Created new subscription for user {landlord.id}")

                # Clean up cache
                for step in range(2, 5):
                    cache_key = f"landlord_registration_{session_id}_step_{step}"
                    cache.delete(cache_key)

                # Prepare response data
                response_data = {
                    'status': 'success',
                    'user_id': landlord.id,
                    'landlord_code': landlord.landlord_code,
                    'email': landlord.email,
                    'full_name': landlord.full_name,
                    'properties_created': created_properties,
                    'subscription': {
                        'plan': subscription.plan,
                        'expiry_date': subscription.expiry_date
                    },
                    'message': 'Landlord registration completed successfully'
                }

                # Send welcome email
                self.send_welcome_email(landlord)

                return Response(response_data, status=status.HTTP_201_CREATED)
                
            except ValidationError as e:
                return Response({
                    'status': 'error',
                    'message': str(e)
                }, status=status.HTTP_400_BAD_REQUEST)
                
            except Exception as e:
                logger.error(f"Error creating landlord user: {str(e)}")
                # If user creation fails but user was created, delete it
                if 'landlord' in locals():
                    landlord.delete()
                return Response({
                    'status': 'error',
                    'message': 'Failed to create landlord account'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            logger.error(f"Unexpected error in landlord registration: {str(e)}")
            return Response({
                'status': 'error',
                'message': 'Internal server error'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_bedroom_count(self, room_type):
        """
        Map room type string to bedroom count
        """
        room_type_mapping = {
            'studio': 0,
            '1-bedroom': 1,
            '2-bedroom': 2,
            '3-bedroom': 3
        }
        return room_type_mapping.get(room_type, 0)

    def send_welcome_email(self, landlord):
        """
        Send welcome email to landlord
        """
        try:
            subject = "Welcome to Makao Rentals - Your Landlord Account is Ready!"
            message = f"""
            Hello {landlord.full_name},

            Welcome to  Makao Rentals! Your landlord account has been successfully created.

            Account Details:
            - Landlord Code: {landlord.landlord_code}
            - Email: {landlord.email}
            - M-Pesa Till: {landlord.mpesa_till_number}

            Your 60-day free trial has been activated. You can now:
            - Manage your properties
            - Add units and set rents
            - Receive rent payments via M-Pesa
            - Track tenant payments

            Login to your dashboard to get started.

            Best regards,
            Makao Rentals Team
            """

            logger.info(f"Welcome email prepared for {landlord.email}: {subject}")
            
        except Exception as e:
            logger.error(f"Failed to send welcome email: {str(e)}")

# In accounts/views.py - ADD THIS VIEW

class UnitListView(generics.ListAPIView):
    """
    Get all units for the authenticated user
    - Landlords: Get all their units across all properties
    - Tenants: Get their assigned unit
    """
    serializer_class = UnitSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        print(f"🔍 UnitListView - User: {user.email}, Type: {user.user_type}")
        
        if user.user_type == 'landlord':
            # Landlords see all units from their properties
            units = Unit.objects.filter(property_obj__landlord=user).select_related(
                'property_obj', 'unit_type', 'tenant'
            )
            print(f"🏠 Landlord units found: {units.count()}")
            return units
            
        elif user.user_type == 'tenant':
            # Tenants see only their assigned unit
            units = Unit.objects.filter(tenant=user).select_related(
                'property_obj', 'unit_type'
            )
            print(f"🏠 Tenant units found: {units.count()}")
            return units
            
        else:
            print("❌ Unknown user type")
            return Unit.objects.none()

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            print(f"✅ UnitListView response: {len(response.data)} units")
            return response
        except Exception as e:
            print(f"❌ UnitListView error: {str(e)}")
            return Response(
                {"error": "Failed to fetch units", "details": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class LandlordProfileView(APIView):
    """Get landlord's own profile information"""
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

# Add this view to handle tenant rejection/deletion
class DeleteTenantView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def delete(self, request, tenant_id):
        logger.info(f"DeleteTenantView: Landlord {request.user.id} attempting to delete tenant {tenant_id}")

        try:
            # Validate tenant exists and belongs to landlord's properties
            tenant = CustomUser.objects.get(
                id=tenant_id, 
                user_type="tenant",
                unit__property_obj__landlord=request.user
            )
            
            tenant_name = tenant.full_name
            tenant_email = tenant.email
            
            # Delete the tenant
            tenant.delete()
            
            logger.info(f"✅ Tenant {tenant_name} ({tenant_email}) deleted by landlord {request.user.id}")

            return Response({
                'message': f'Tenant {tenant_name} has been successfully removed',
                'status': 'success'
            }, status=200)

        except CustomUser.DoesNotExist:
            logger.error(f"Tenant {tenant_id} not found or not associated with landlord {request.user.id}")
            return Response({
                "error": "Tenant not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in DeleteTenantView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)

@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def get_pending_applications(request):
    """ENHANCED: Get tenants without units (pending applications)"""
    if request.user.user_type != 'landlord':
        return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)
    
    # Get tenants without units OR tenants not assigned to this landlord's units
    all_tenants = CustomUser.objects.filter(user_type='tenant')
    landlord_tenant_ids = Unit.objects.filter(
        property_obj__landlord=request.user
    ).exclude(tenant__isnull=True).values_list('tenant_id', flat=True)
    
    pending_tenants = all_tenants.exclude(id__in=landlord_tenant_ids)
    
    serializer = TenantWithUnitSerializer(pending_tenants, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def assign_tenant_to_unit(request, unit_id):
    """ENHANCED: Assign tenant to unit"""
    unit = get_object_or_404(Unit, id=unit_id)
    
    # Check if user owns this unit
    if unit.property_obj.landlord != request.user:
        return Response({"error": "You don't own this unit"}, status=status.HTTP_403_FORBIDDEN)
    
    tenant_id = request.data.get('tenant_id')
    if not tenant_id:
        return Response({"error": "tenant_id is required"}, status=status.HTTP_400_BAD_REQUEST)
    
    tenant = get_object_or_404(CustomUser, id=tenant_id, user_type='tenant')
    
    # Check if unit is available
    if not unit.is_available:
        return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Check if tenant already has a unit
    if Unit.objects.filter(tenant=tenant, is_available=False).exists():
        return Response({"error": "Tenant already has a unit assigned"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Assign tenant to unit
    unit.tenant = tenant
    unit.is_available = False
    unit.assigned_date = timezone.now()
    unit.save()
    
    # Create or update tenant profile
    TenantProfile.objects.update_or_create(
        tenant=tenant,
        defaults={'current_unit': unit, 'move_in_date': timezone.now()}
    )
    
    return Response({
        "success": True,
        "message": f"Tenant {tenant.full_name} assigned to unit {unit.unit_number}",
        "unit": UnitSerializer(unit).data
    })

@api_view(['POST'])
@permission_classes([permissions.IsAuthenticated])
def remove_tenant_from_unit(request, unit_id):
    """ENHANCED: Remove tenant from unit"""
    unit = get_object_or_404(Unit, id=unit_id)
    
    # Check if user owns this unit
    if unit.property_obj.landlord != request.user:
        return Response({"error": "You don't own this unit"}, status=status.HTTP_403_FORBIDDEN)
    
    if not unit.tenant:
        return Response({"error": "No tenant assigned to this unit"}, status=status.HTTP_400_BAD_REQUEST)
    
    tenant_name = unit.tenant.full_name
    unit.remove_tenant()
    
    # Update tenant profile
    TenantProfile.objects.filter(tenant=unit.tenant, current_unit=unit).update(current_unit=None)
    
    return Response({
        "success": True,
        "message": f"Tenant {tenant_name} removed from unit {unit.unit_number}"
    })
# ===== ENHANCED TENANT MANAGEMENT VIEWS =====
@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def get_users(request):
    """Get all users with proper filtering - ENHANCED"""
    user_type = request.GET.get('user_type')
    
    if request.user.user_type == 'landlord':
        # Landlords can see their tenants and themselves
        if user_type == 'tenant':
            # Get tenants assigned to landlord's units
            tenants = CustomUser.objects.filter(
                user_type='tenant',
                assigned_units__property_obj__landlord=request.user
            ).distinct()
        else:
            # Return all users (with limitations)
            tenants = CustomUser.objects.filter(
                Q(user_type='tenant', assigned_units__property_obj__landlord=request.user) |
                Q(id=request.user.id)
            ).distinct()
    else:
        # Tenants can only see themselves
        tenants = CustomUser.objects.filter(id=request.user.id)
    
    serializer = CustomUserSerializer(tenants, many=True)
    return Response(serializer.data)

@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def get_tenants_with_units(request):
    """ENHANCED: Get tenants with their unit information"""
    if request.user.user_type != 'landlord':
        return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)
    
    # Get tenants assigned to landlord's properties
    tenants = CustomUser.objects.filter(
        user_type='tenant',
        assigned_units__property_obj__landlord=request.user
    ).distinct()
    
    serializer = TenantWithUnitSerializer(tenants, many=True)
    return Response(serializer.data)

@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def landlord_dashboard(request):
    """ENHANCED: Landlord dashboard with complete stats"""
    if request.user.user_type != 'landlord':
        return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)
    
    # Calculate statistics
    properties = Property.objects.filter(landlord=request.user)
    units = Unit.objects.filter(property_obj__landlord=request.user)
    
    total_properties = properties.count()
    total_units = units.count()
    occupied_units = units.filter(is_available=False).count()
    vacant_units = units.filter(is_available=True).count()
    
    # Get unique tenants
    unique_tenants = CustomUser.objects.filter(
        assigned_units__property_obj__landlord=request.user
    ).distinct().count()
    
    # Get pending applications (tenants without units in this landlord's properties)
    all_tenants = CustomUser.objects.filter(user_type='tenant')
    landlord_tenant_ids = units.exclude(tenant__isnull=True).values_list('tenant_id', flat=True)
    pending_applications = all_tenants.exclude(id__in=landlord_tenant_ids).count()
    
    # Rent calculations
    total_rent_collected = units.aggregate(
        total=Sum('rent_paid')
    )['total'] or 0
    
    total_rent_due = units.aggregate(
        total=Sum('rent_remaining')
    )['total'] or 0
    
    # Recent tenants with units
    recent_tenants = CustomUser.objects.filter(
        assigned_units__property_obj__landlord=request.user
    ).distinct()[:5]
    
    dashboard_data = {
        'total_properties': total_properties,
        'total_units': total_units,
        'occupied_units': occupied_units,
        'vacant_units': vacant_units,
        'total_tenants': unique_tenants,
        'pending_applications': pending_applications,
        'total_rent_collected': total_rent_collected,
        'total_rent_due': total_rent_due,
        'recent_tenants': TenantWithUnitSerializer(recent_tenants, many=True).data,
        'recent_payments': []
    }
    
    serializer = LandlordDashboardSerializer(dashboard_data)
    return Response(serializer.data)

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    # from accounts/urls.py
    path('api/accounts/', include('accounts.urls')),
    # from payments/urls.py
    path("api/payments/", include("payments.urls")),
    # from communication/urls.py
    path("api/communication/", include("communication.urls")),
]
import { BrowserRouter as Router, Routes, Route, Navigate } from "react-router-dom"
import { AuthProvider, useAuth } from "./context/AuthContext"
import ContextProvider from "./context/AppContext"
import { TenantToastProvider } from "./context/TenantToastContext"
import { NotificationProvider } from "./context/NotificationContext"
import { ToastProvider } from "./context/ToastContext"
import { AddPropertyForm } from "./context/AppContext"

// auth & layout
import UnifiedAuthSystem from "./components/Login and Sign Up/LoginForm"

import AdminLayout from "./components/Admin/AdminLayout"
import TenantLayout from "./components/Tenant/TenantLayout"

import ForgotPasswordRequest from "./components/Login and Sign Up/ForgotPasswordRequest"
import ResetPassword from "./components/Login and Sign Up/ResetPassword"
import ResetPasswordSuccess from "./components/Login and Sign Up/ResetPasswordSuccess"

// admin pages
import AdminDashboard from "./components/Admin/AdminDashboard"
import AdminReports from "./components/Admin/AdminReports"
import AdminPayments from "./components/Admin/AdminPayments"
import AdminSettings from "./components/Admin/AdminSettings"
import AdminOrganisation from "./components/Admin/AdminOrganisation"
import AdminTenants from "./components/Admin/AdminTenants"
import AdminHelp from "./components/Admin/AdminHelp"
import TenantTransactions from "./components/Admin/TenantTransactions"
import TenantDetails from "./components/Admin/TenantDetailsPage"

// NEW: Subscription and SMS pages
import SubscriptionPage from "./components/Admin/SubscriptionPage"
import SMSPurchasePage from "./components/Admin/SMSPurchasePage"

// tenant pages
import TenantDashboard from "./components/Tenant/TenantDashboard"
import TenantPaymentCenter from "./components/Tenant/TenantPaymentCenter"
import TenantReportIssue from "./components/Tenant/TenantReportIssue"
import TenantSettings from "./components/Tenant/TenantSettings"

// Loading component
function LoadingSpinner() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-gray-600">Loading...</p>
      </div>
    </div>
  );
}

function ProtectedRoute({ children, role }) {
  const { isLoggedIn, userType, isLoading } = useAuth()

  if (isLoading) {
    return <LoadingSpinner />
  }

  if (!isLoggedIn) return <Navigate to="/login" replace />
  if (role && userType !== role) return <Navigate to="/login" replace />

  return children
}

function AppContent() {
  const { isLoggedIn, userType, isLoading } = useAuth()

  // Show loading spinner while checking auth status
  if (isLoading) {
    return <LoadingSpinner />
  }

  return (
    <Routes>
      {/* Public login */}
      <Route
        path="/login"
        element={
          isLoggedIn ? (
            <Navigate to={userType === "landlord" ? "/admin" : "/tenant"} replace />
          ) : (
            <UnifiedAuthSystem />
          )
        }
      />

      <Route path="/forgot-password" element={<ForgotPasswordRequest />} />
      <Route path="/reset-password" element={<ResetPassword />} />
      <Route path="/reset-success" element={<ResetPasswordSuccess />} />

      {/* Admin routes */}
      <Route
        path="/admin/*"
        element={
          <ProtectedRoute role="landlord">
            <AdminLayout />
          </ProtectedRoute>
        }
      >
        <Route index element={<AdminOrganisation />} />
        <Route path="dashboard" element={<AdminDashboard />} />
        <Route path="add-property" element={<AddPropertyForm />} />
        <Route path="tenants" element={<AdminTenants />} />
        <Route path="tenants/:tenantId/transactions" element={<TenantTransactions />} />
        <Route path="tenants/:tenantId/details" element={<TenantDetails />} />
        <Route path="help" element={<AdminHelp />} />
        <Route path="reports" element={<AdminReports />} />
        <Route path="payments" element={<AdminPayments />} />
        <Route path="settings" element={<AdminSettings />} />
        <Route path="organisation" element={<AdminOrganisation />} />
        
        {/* NEW ROUTES: Subscription and SMS Purchase */}
        <Route path="subscription" element={<SubscriptionPage />} />
        <Route path="sms-purchase" element={<SMSPurchasePage />} />
      </Route>

      {/* Tenant routes */}
      <Route
        path="/tenant/*"
        element={
          <ProtectedRoute role="tenant">
            <TenantToastProvider>
              <TenantLayout />
            </TenantToastProvider>
          </ProtectedRoute>
        }
      >
        <Route index element={<TenantDashboard />} />
        <Route path="payments" element={<TenantPaymentCenter />} />
        <Route path="report" element={<TenantReportIssue />} />
        <Route path="settings" element={<TenantSettings />} />
      </Route>

      {/* Default → login */}
      <Route path="*" element={<Navigate to="/login" replace />} />
    </Routes>
  )
}

export default function App() {
  return (
    <ContextProvider>
      <ToastProvider>
        <NotificationProvider>
          <AuthProvider>
            <Router>
              <AppContent />
            </Router>
          </AuthProvider>
        </NotificationProvider>
      </ToastProvider>
    </ContextProvider>
  )
}
from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

class Report(models.Model):
    ISSUE_CATEGORIES = [
        ('electrical', 'Electrical'),
        ('plumbing', 'Plumbing'),
        ('noise', 'Noise'),
        ('safety', 'Safety/Violence'),
        ('wifi', 'WiFi'),
        ('maintenance', 'General Maintenance'),
        ('pest', 'Pest Control'),
        ('security', 'Security'),
        ('cleanliness', 'Cleanliness'),
        ('other', 'Other'),
    ]

    PRIORITY_LEVELS = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ]

    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('resolved', 'Resolved'),
        ('closed', 'Closed'),
    ]

    # Basic required fields
    tenant = models.ForeignKey(
        CustomUser, 
        on_delete=models.CASCADE, 
        related_name='reports',
        limit_choices_to={'user_type': 'tenant'}
    )
    unit = models.ForeignKey(
        Unit, 
        on_delete=models.CASCADE, 
        related_name='reports'
    )
    issue_category = models.CharField(max_length=20, choices=ISSUE_CATEGORIES)
    priority_level = models.CharField(max_length=10, choices=PRIORITY_LEVELS, default='medium')
    issue_title = models.CharField(max_length=255)
    description = models.TextField()
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='open')

    # Additional fields you added
    reported_date = models.DateTimeField(auto_now_add=True)
    resolved_date = models.DateTimeField(null=True, blank=True)
    assigned_to = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        limit_choices_to={'user_type': 'landlord'},
        related_name='assigned_reports'
    )
    estimated_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    actual_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    # File attachments
    attachment = models.FileField(upload_to='report_attachments/', null=True, blank=True)
    
    class Meta:
        ordering = ['-reported_date']
        verbose_name = 'Maintenance Report'
        verbose_name_plural = 'Maintenance Reports'

    def save(self, *args, **kwargs):
        # Auto-assign priority based on category if not set
        if not self.priority_level or self.priority_level == 'medium':
            urgent_categories = ['safety', 'electrical', 'plumbing', 'security']
            self.priority_level = 'urgent' if self.issue_category in urgent_categories else 'medium'
        
        # Auto-set resolved_date when status changes to resolved
        if self.status == 'resolved' and not self.resolved_date:
            self.resolved_date = timezone.now()
        elif self.status != 'resolved' and self.resolved_date:
            self.resolved_date = None
            
        super().save(*args, **kwargs)

    @property
    def days_open(self):
        """Calculate how many days the report has been open"""
        if self.status == 'resolved' and self.resolved_date:
            return (self.resolved_date - self.reported_date).days
        return (timezone.now() - self.reported_date).days

    @property
    def is_urgent(self):
        """Check if the report is urgent based on priority and days open"""
        return self.priority_level == 'urgent' or self.days_open > 7

    def __str__(self):
        return f"Report #{self.id} - {self.issue_title} ({self.tenant.full_name})"
from rest_framework import serializers
from .models import Report
from accounts.models import CustomUser, Unit, Property

class ReportSerializer(serializers.ModelSerializer):
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)
    unit_number = serializers.CharField(source='unit.unit_number', read_only=True)
    property_name = serializers.CharField(source='unit.property_obj.name', read_only=True)
    days_open = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = Report
        fields = [
            'id', 'tenant', 'tenant_name', 'unit', 'unit_number', 'property_name',
            'issue_category', 'priority_level', 'issue_title', 'description',
            'status', 'reported_date', 'resolved_date', 'assigned_to',
            'estimated_cost', 'actual_cost', 'attachment', 'days_open'
        ]
        read_only_fields = ['tenant', 'reported_date', 'days_open']

    def validate(self, data):
        # Ensure tenants can only report issues for their own units
        if self.instance and self.instance.tenant != self.context['request'].user:
            raise serializers.ValidationError("You can only modify your own reports")
        return data

class UpdateReportStatusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Report
        fields = ['status']
        read_only_fields = []

class SendEmailSerializer(serializers.Serializer):
    subject = serializers.CharField(max_length=255)
    message = serializers.CharField()
    tenants = serializers.ListField(
        child=serializers.PrimaryKeyRelatedField(queryset=CustomUser.objects.filter(user_type='tenant')),
        required=False,
        allow_empty=True
    )
    send_to_all = serializers.BooleanField(default=False)

    def validate(self, data):
        if not data.get('send_to_all') and not data.get('tenants'):
            raise serializers.ValidationError("Either provide a list of tenants or set send_to_all to True.")
        if data.get('send_to_all') and data.get('tenants'):
            raise serializers.ValidationError("Cannot specify tenants when send_to_all is True.")
        return data

    def validate_tenants(self, value):
        # Ensure all tenants belong to the landlord's properties
        request = self.context.get('request')
        if request and request.user.user_type == 'landlord':
            landlord_properties = Property.objects.filter(landlord=request.user)
            tenant_units = Unit.objects.filter(property_obj__in=landlord_properties, tenant__in=value)
            valid_tenants = set(tenant_units.values_list('tenant', flat=True))
            if set(t.id for t in value) != valid_tenants:
                raise serializers.ValidationError("Some tenants do not belong to your properties.")
        return value
from django.urls import path
from .views import (
    CreateReportView,
    OpenReportsView,
    UrgentReportsView,
    InProgressReportsView,
    ResolvedReportsView,
    UpdateReportStatusView,
    SendEmailView,ReportListView,
)

urlpatterns = [
    # Create a new report (POST)
    path('reports/create/', CreateReportView.as_view(), name='create-report'),  # Added /create/

    # List open reports for the authenticated user (GET)
    path('reports/open/', OpenReportsView.as_view(), name='open-reports'),

    # List urgent reports for the authenticated user (GET)
    path('reports/urgent/', UrgentReportsView.as_view(), name='urgent-reports'),

    # List in-progress reports for the authenticated user (GET)
    path('reports/in-progress/', InProgressReportsView.as_view(), name='in-progress-reports'),
    # List all reports (GET) - ADD THIS ENDPOINT
    path('reports/', ReportListView.as_view(), name='list-reports'),

    # List resolved reports for the authenticated user (GET)
    path('reports/resolved/', ResolvedReportsView.as_view(), name='resolved-reports'),

    # Update the status of a specific report (PATCH/PUT)
    path('reports/<int:pk>/update-status/', UpdateReportStatusView.as_view(), name='update-report-status'),

    # Send email to tenants (POST)
    path('reports/send-email/', SendEmailView.as_view(), name='send-email'),  # Added /reports/ prefix
]
from rest_framework import generics, permissions
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Report
from .serializers import ReportSerializer, UpdateReportStatusSerializer, SendEmailSerializer
from .permissions import IsTenantWithUnit, IsLandlordWithActiveSubscription
from accounts.permissions import CanAccessReport
from accounts.models import CustomUser, Unit
from .messaging import send_landlord_email
from rest_framework.permissions import IsAuthenticated


class CreateReportView(generics.CreateAPIView):
    queryset = Report.objects.all()
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated, IsTenantWithUnit]

    def perform_create(self, serializer):
        report = serializer.save()
        # Import here to avoid circular imports
        from app.tasks import send_report_email_task
        send_report_email_task.delay(report.id)

class ReportListView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            # Landlords see reports from their properties
            from accounts.models import Property
            landlord_properties = Property.objects.filter(landlord=user)
            return Report.objects.filter(unit__property_obj__in=landlord_properties)
        return Report.objects.none()
    
class OpenReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='open')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='open')
        return Report.objects.none()

class UrgentReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, priority_level='urgent')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, priority_level='urgent')
        return Report.objects.none()

class InProgressReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='in_progress')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='in_progress')
        return Report.objects.none()

class ResolvedReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='resolved')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='resolved')
        return Report.objects.none()

class UpdateReportStatusView(generics.UpdateAPIView):
    queryset = Report.objects.all()
    serializer_class = UpdateReportStatusSerializer
    permission_classes = [permissions.IsAuthenticated, CanAccessReport]

class SendEmailView(APIView):
    permission_classes = [permissions.IsAuthenticated, IsLandlordWithActiveSubscription]

    def post(self, request):
        serializer = SendEmailSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            subject = serializer.validated_data['subject']
            message = serializer.validated_data['message']
            send_to_all = serializer.validated_data['send_to_all']

            if send_to_all:
                # Get all tenants of the landlord
                landlord_properties = request.user.property_set.all()
                tenants = CustomUser.objects.filter(
                    user_type='tenant',
                    unit__property_obj__in=landlord_properties
                ).distinct()
            else:
                tenants = serializer.validated_data['tenants']

            send_landlord_email(subject, message, tenants)
            return Response({"message": "Emails sent successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
class ReportStatisticsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        user = request.user
        if user.user_type == 'landlord':
            reports = Report.objects.filter(unit__property_obj__landlord=user)
        else:
            reports = Report.objects.filter(tenant=user)
            
        stats = {
            'total': reports.count(),
            'open': reports.filter(status='open').count(),
            'in_progress': reports.filter(status='in_progress').count(),
            'resolved': reports.filter(status='resolved').count(),
            'urgent': reports.filter(priority_level='urgent', status__in=['open', 'in_progress']).count(),
            'average_resolution_time': self.get_average_resolution_time(reports),
        }
        return Response(stats)
    
    def get_average_resolution_time(self, reports):
        resolved_reports = reports.filter(status='resolved', resolved_date__isnull=False)
        if not resolved_reports:
            return 0
            
        total_days = sum((r.resolved_date - r.reported_date).days for r in resolved_reports)
        return total_days / resolved_reports.count()
from django.db import models
from accounts.models import CustomUser, Unit, Subscription
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid

class Payment(models.Model):
    PAYMENT_TYPES = [
        ('rent', 'Rent'),
        ('deposit', 'Deposit'),
        ('maintenance', 'Maintenance'),
        ('other', 'Other'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    tenant = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'tenant'},
        related_name='payments',
        null=True,  # ✅ ADD THIS
        blank=True  # ✅ ADD THIS
    )
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='payments')
    
    # Payment details
    payment_type = models.CharField(max_length=20, choices=PAYMENT_TYPES, default='rent')
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # M-Pesa fields
    mpesa_receipt = models.CharField(max_length=50, blank=True, null=True)
    mpesa_checkout_request_id = models.CharField(max_length=100, blank=True, null=True)
    
    # Additional fields
    reference_number = models.CharField(max_length=50, unique=True, blank=True)
    description = models.TextField(blank=True)
    payment_method = models.CharField(max_length=20, default='mpesa', choices=[
        ('mpesa', 'M-Pesa'),
        ('cash', 'Cash'),
        ('bank', 'Bank Transfer'),
    ])
    
    # Timestamps - using created_at consistently
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    failure_reason = models.TextField(blank=True, null=True)

    def clean(self):
        if self.payment_type == 'rent' and not self.unit:
            raise ValidationError("Rent payments must be associated with a unit")
            
    def save(self, *args, **kwargs):
        # Generate reference number if not set
        if not self.reference_number:
            self.reference_number = f"PAY-{uuid.uuid4().hex[:12].upper()}"
        super().save(*args, **kwargs)
        
    def __str__(self):
        return f"Payment {self.reference_number} - {self.amount} ({self.status})"


class SubscriptionPayment(models.Model):
    user = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt_number = models.CharField(
        max_length=50,
        blank=True,  # Allow empty strings
        null=True,
        default=""
    )
    mpesa_checkout_request_id = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="M-Pesa checkout request ID for tracking STK push"
    )
    transaction_date = models.DateTimeField(auto_now_add=True)
    subscription_type = models.CharField(max_length=20, choices=Subscription.PLAN_CHOICES)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    class Meta:
        # Simple unique constraint for non-empty receipt numbers
        constraints = [
            models.UniqueConstraint(
                fields=['mpesa_receipt_number'],
                name='unique_mpesa_receipt',
                condition=~models.Q(mpesa_receipt_number='')
            )
        ]

    def __str__(self):
        return f"Subscription Payment {self.id} - {self.subscription_type}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    def _get_plan_duration(self):
        durations = {
            "free": timedelta(days=60),
            "starter": timedelta(days=30),
            "basic": timedelta(days=30),
            "professional": timedelta(days=30),
            # "onetime" will be treated as lifetime (None) by the subscription logic
        }
        return durations.get(self.subscription_type, timedelta(days=30))
from rest_framework import serializers
from .models import Payment, SubscriptionPayment

class PaymentSerializer(serializers.ModelSerializer):
    date = serializers.DateTimeField(source='created_at', read_only=True)  # FIX: Use created_at
    phone = serializers.CharField(source='tenant.phone_number', read_only=True)
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)
    unit_number = serializers.CharField(source='unit.unit_number', read_only=True)
    
    # Add status display field to map backend status to frontend
    status_display = serializers.SerializerMethodField()

    class Meta:
        model = Payment
        fields = [
            'id', 'tenant', 'tenant_name', 'unit', 'unit_number', 
            'payment_type', 'amount', 'mpesa_receipt', 'date', 'phone', 
            'status', 'status_display', 'reference_number'
        ]
        read_only_fields = ['created_at', 'status']

    def get_status_display(self, obj):
        """Map backend status to frontend display status"""
        status_map = {
            'completed': 'Success',
            'pending': 'Pending', 
            'failed': 'Failed',
            'cancelled': 'Failed'
        }
        return status_map.get(obj.status, obj.status)

class SubscriptionPaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPayment
        fields = '__all__'
        read_only_fields = ['transaction_date']
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from django.conf import settings
from django.shortcuts import get_object_or_404
from django.core.cache import cache
from django.utils import timezone
from django.db.models import Sum, Q
from django.http import HttpResponse
import json
import requests
from decimal import Decimal
from datetime import datetime, timedelta
import csv
import io
import uuid
import base64
import logging

from accounts.models import Unit, UnitType, Property, Subscription
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer

logger = logging.getLogger(__name__)

def validate_mpesa_payment(phone_number, amount):
    """
    Validate payment parameters before initiating STK push
    """
    try:
        # Validate phone number format
        if not phone_number or not isinstance(phone_number, str):
            return False, "Phone number is required"
        
        # Clean phone number
        phone_number = phone_number.strip().replace(' ', '').replace('+', '')
        
        # Convert to 254 format if needed
        if phone_number.startswith('0') and len(phone_number) == 10:
            phone_number = '254' + phone_number[1:]
        elif phone_number.startswith('7') and len(phone_number) == 9:
            phone_number = '254' + phone_number
        elif phone_number.startswith('254') and len(phone_number) == 12:
            # Already in correct format
            pass
        else:
            return False, "Phone number must be in format 254XXXXXXXXX"
        
        # Validate phone number contains only digits
        if not phone_number.isdigit():
            return False, "Phone number must contain only digits"
        
        # Validate amount
        try:
            amount = float(amount)
            if amount <= 0:
                return False, "Amount must be greater than 0"
            
            if amount > 150000:  # M-Pesa transaction limit
                return False, "Amount exceeds M-Pesa transaction limit (KES 150,000)"
            if amount < 1:  # Minimum amount
                return False, "Amount must be at least KES 1"
        except (ValueError, TypeError):
            return False, "Amount must be a valid number"
        
        return True, phone_number  # Return cleaned phone number
    
    except Exception as e:
        logger.error(f"Payment validation error: {str(e)}")
        return False, "Payment validation failed"
# ------------------------------
# M-PESA STK PUSH FUNCTIONS
# ------------------------------
@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push(request, unit_id):
    """
    Initiate REAL STK push for rent payment
    """
    try:
        unit = get_object_or_404(Unit, id=unit_id)
        tenant = request.user

        # Validate tenant owns the unit AND user is a tenant
        if request.user.user_type != 'tenant':
            return Response({"error": "Only tenants can make rent payments"}, status=status.HTTP_403_FORBIDDEN)
        # Validate tenant owns the unit
        if unit.tenant != tenant:
            return Response({"error": "You don't have permission to pay for this unit"}, status=status.HTTP_403_FORBIDDEN)

        # Check if rent is already paid
        if unit.rent_remaining <= 0:
            return Response({"error": "Rent is already paid for this unit"}, status=status.HTTP_400_BAD_REQUEST)

        amount = unit.rent_remaining
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        # Use cleaned phone number
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": f"RENT-{unit.unit_code}",
            "TransactionDesc": f"Rent payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL based on environment
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        logger.info(f"Sending STK push to: {url}")
        logger.info(f"Payload: {payload}")

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        logger.info(f"STK push response: {response_data}")

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="rent",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_{response_data['CheckoutRequestID']}"
            cache_data = {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }
            cache.set(cache_key, cache_data, timeout=300)  # 5 minutes

            logger.info(f"STK push initiated successfully. Payment ID: {payment.id}, Cache Key: {cache_key}")

            return Response({
                "success": True,
                "message": "STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate STK push",
                "details": error_message,
                "response_data": response_data
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push_subscription(request):
    """
    Initiate STK push for subscription payment
    """
    try:
        user = request.user
        plan = request.data.get('plan')
        phone_number = request.data.get('phone_number')

        if not plan or not phone_number:
            return Response({"error": "Plan and phone number are required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate plan
        plan_amounts = {
            'starter': 1000,
            'basic': 2000,
            'professional': 3000
        }

        if plan not in plan_amounts:
            return Response({"error": "Invalid plan"}, status=status.HTTP_400_BAD_REQUEST)

        amount = plan_amounts[plan]

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": amount,
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": f"SUB-{user.id}",
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending subscription payment record
            subscription_payment = SubscriptionPayment.objects.create(
                user=user,
                amount=Decimal(amount),
                subscription_type=plan,
                status="Pending",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_sub_{response_data['CheckoutRequestID']}"
            cache.set(cache_key, {
                "subscription_payment_id": subscription_payment.id,
                "user_id": user.id,
                "plan": plan,
                "amount": amount
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "Subscription STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "subscription_payment_id": subscription_payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            return Response({
                "error": "Failed to initiate subscription STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"Subscription STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ------------------------------
# M-PESA CALLBACK FUNCTIONS (FIXED VERSIONS)
# ------------------------------
@csrf_exempt
def mpesa_rent_callback(request):
    """
    Enhanced rent payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Rent callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Rent callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached payment data
            cached_data = cache.get(f"stk_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit
                    
                    # Update payment record
                    payment.status = "Success"
                    payment.mpesa_receipt = mpesa_receipt or f"RENT-{payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    
                    if amount:
                        payment.amount = Decimal(amount)
                    
                    payment.save()

                    # Update unit rent_paid
                    paid_amount = Decimal(amount) if amount else payment.amount
                    unit.rent_paid += paid_amount
                    unit.rent_remaining = unit.rent - unit.rent_paid
                    unit.save()

                    logger.info(f"Rent payment {payment.id} completed successfully for unit {unit.unit_number}")
                    logger.info(f"Unit {unit.unit_number} rent paid: {unit.rent_paid}, remaining: {unit.rent_remaining}")
                    
                    # Clear cache
                    cache.delete(f"stk_{checkout_request_id}")

                except Payment.DoesNotExist:
                    logger.error(f"Rent payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for rent payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing rent callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for rent checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Rent payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "Failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Rent payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Rent payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in rent callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in rent callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Enhanced deposit payment callback handler with registration support
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Deposit callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Deposit callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])

            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Check both regular and registration cache keys
            cached_data = cache.get(f"stk_deposit_{checkout_request_id}")
            is_registration = False

            if not cached_data:
                cached_data = cache.get(f"stk_deposit_reg_{checkout_request_id}")
                is_registration = True

            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit

                    # Update payment record
                    payment.status = "completed"
                    payment.mpesa_receipt = mpesa_receipt or f"DEP-{payment.id}-{uuid.uuid4().hex[:8].upper()}"

                    if amount:
                        payment.amount = Decimal(amount)

                    payment.save()

                    # For registration payments, reserve the unit
                    # The tenant will be linked during registration completion
                    if is_registration:
                        unit.is_available = False  # Reserve the unit
                        unit.save()
                        logger.info(f"Unit {unit.unit_number} reserved via registration deposit payment")
                    else:
                        # Regular deposit payment - assign tenant if available
                        if payment.tenant:
                            unit.is_available = False
                            unit.tenant = payment.tenant
                            unit.assigned_date = timezone.now()
                            unit.save()

                    logger.info(f"Deposit payment {payment.id} completed successfully for unit {unit.unit_number}")

                    # Clear cache
                    cache_key = f"stk_deposit_reg_{checkout_request_id}" if is_registration else f"stk_deposit_{checkout_request_id}"
                    cache.delete(cache_key)

                except Payment.DoesNotExist:
                    logger.error(f"Deposit payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for deposit payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing deposit callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for deposit checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Deposit payment failed - ResultCode: {result_code}, Description: {result_desc}")

            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_deposit_{checkout_request_id}") or cache.get(f"stk_deposit_reg_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Deposit payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Deposit payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in deposit callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in deposit callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Enhanced subscription payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Subscription callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Subscription callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached subscription payment data
            cached_data = cache.get(f"stk_sub_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    subscription_payment = SubscriptionPayment.objects.get(
                        id=cached_data["subscription_payment_id"]
                    )
                    user = subscription_payment.user
                    
                    # Update subscription payment record
                    subscription_payment.status = "Success"
                    subscription_payment.mpesa_receipt_number = (
                        mpesa_receipt or 
                        f"SUB-{subscription_payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    )
                    
                    if amount:
                        subscription_payment.amount = Decimal(amount)
                    
                    subscription_payment.save()

                    # Update or create user subscription
                    subscription, created = Subscription.objects.get_or_create(
                        user=user,
                        defaults={
                            'plan': subscription_payment.subscription_type,
                            'expiry_date': timezone.now() + timedelta(days=30)
                        }
                    )
                    
                    if not created:
                        # Update existing subscription
                        subscription.plan = subscription_payment.subscription_type
                        subscription.expiry_date = timezone.now() + timedelta(days=30)
                        subscription.save()

                    logger.info(f"Subscription payment {subscription_payment.id} completed successfully")
                    logger.info(f"User {user.email} subscription updated to {subscription_payment.subscription_type}")
                    
                    # Clear cache
                    cache.delete(f"stk_sub_{checkout_request_id}")

                except SubscriptionPayment.DoesNotExist:
                    logger.error(f"Subscription payment not found for ID: {cached_data['subscription_payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing subscription callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for subscription checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Subscription payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_sub_{checkout_request_id}")
                if cached_data:
                    try:
                        subscription_payment = SubscriptionPayment.objects.get(
                            id=cached_data["subscription_payment_id"]
                        )
                        subscription_payment.status = "Failed"
                        subscription_payment.failure_reason = result_desc
                        subscription_payment.save()
                        logger.info(f"Subscription payment {subscription_payment.id} marked as failed: {result_desc}")
                    except SubscriptionPayment.DoesNotExist:
                        logger.error(f"Subscription payment not found for failed callback: {cached_data['subscription_payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in subscription callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in subscription callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})
    
class InitiateDepositPaymentRegistrationView(APIView):
    """
    Initiate deposit payment during tenant registration (no auth required)
    """
    permission_classes = []  # No authentication required

    def post(self, request):
        try:
            unit_id = request.data.get('unit_id')
            phone_number = request.data.get('phone_number')
            session_id = request.data.get('session_id')
            amount = request.data.get('amount')  # ✅ GET AMOUNT FROM FRONTEND

            logger.info(f"Registration deposit STK push request: unit_id={unit_id}, phone={phone_number}, amount={amount}")

            # Parse unit_id as integer
            try:
                unit_id = int(unit_id)
            except (ValueError, TypeError):
                return Response({"error": "Unit ID must be a valid integer"}, status=status.HTTP_400_BAD_REQUEST)

            if not phone_number:
                return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

            unit = get_object_or_404(Unit, id=unit_id)

            if not unit.is_available:
                return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

            # ✅ USE AMOUNT FROM FRONTEND, FALLBACK TO UNIT DEPOSIT OR RENT
            if amount:
                try:
                    amount = float(amount)
                except (ValueError, TypeError):
                    return Response({"error": "Invalid amount format"}, status=status.HTTP_400_BAD_REQUEST)
            else:
                # Fallback: use deposit if set, otherwise use rent
                amount = float(unit.deposit) if unit.deposit and float(unit.deposit) > 0 else float(unit.rent)

            # ✅ VALIDATE AMOUNT BEFORE PROCEEDING
            if amount <= 0:
                logger.error(f"Invalid amount for unit {unit.id}: {amount}")
                return Response({"error": "Deposit amount must be greater than 0"}, status=status.HTTP_400_BAD_REQUEST)

            logger.info(f"Processing deposit payment: amount={amount}, unit={unit.unit_number}")

            # Validate phone number
            is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
            if not is_valid:
                logger.error(f"Phone validation failed: {validation_result}")
                return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)

            phone_number = validation_result

            # Generate access token
            access_token = generate_access_token()
            if not access_token:
                logger.error("Failed to generate M-Pesa access token")
                return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            logger.info(f"Access token generated successfully: {access_token[:20]}...")

            # Prepare STK push request
            timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
            password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
            password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

            payload = {
                "BusinessShortCode": settings.MPESA_SHORTCODE,
                "Password": password,
                "Timestamp": timestamp,
                "TransactionType": "CustomerPayBillOnline",
                "Amount": int(amount),  # ✅ ENSURE IT'S AN INTEGER
                "PartyA": phone_number,
                "PartyB": settings.MPESA_SHORTCODE,
                "PhoneNumber": phone_number,
                "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
                "AccountReference": f"DEPOSIT-REG-{unit.unit_code}",
                "TransactionDesc": f"Deposit payment for {unit.unit_number}"
            }

            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }

            # Use correct URL
            if settings.MPESA_ENV == "sandbox":
                url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
            else:
                url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

            logger.info(f"Sending STK push request to: {url}")
            logger.info(f"Payload: {payload}")

            response = requests.post(url, json=payload, headers=headers, timeout=30)
            response_data = response.json()

            logger.info(f"M-Pesa response: Status={response.status_code}, Data={response_data}")

            if response.status_code == 200 and response_data.get("ResponseCode") == "0":
                # ✅ FIX: Create payment without tenant (will be linked later during registration)
                payment = Payment.objects.create(
                    unit=unit,
                    amount=amount,
                    status="pending",
                    payment_type="deposit",
                    mpesa_checkout_request_id=response_data["CheckoutRequestID"],
                    # tenant is NULL for registration payments - this is OK now
                )

                # Cache checkout request ID for callback with registration data
                cache_key = f"stk_deposit_reg_{response_data['CheckoutRequestID']}"
                cache_data = {
                    "payment_id": payment.id,
                    "unit_id": unit.id,
                    "amount": float(amount),
                    "phone_number": phone_number,
                    "session_id": session_id  # Link to registration session
                }
                cache.set(cache_key, cache_data, timeout=300)  # 5 minutes

                logger.info(f"✅ Registration deposit STK push initiated successfully: payment_id={payment.id}, checkout_id={response_data['CheckoutRequestID']}")

                return Response({
                    "success": True,
                    "message": "Deposit STK push initiated successfully",
                    "checkout_request_id": response_data["CheckoutRequestID"],
                    "payment_id": payment.id
                })

            else:
                error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
                logger.error(f"Registration deposit STK push failed: {error_message}")
                logger.error(f"Full response: {response_data}")
                return Response({
                    "error": "Failed to initiate deposit STK push",
                    "details": error_message
                }, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:
            logger.error(f"❌ Registration deposit payment error: {str(e)}", exc_info=True)
            return Response({"error": "Internal server error", "details": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class InitiateDepositPaymentView(APIView):
    """
    Initiate REAL deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)

        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"DEPOSIT-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }, timeout=300)  # 5 minutes

            logger.info(f"Deposit STK push initiated for payment {payment.id}, amount {amount}")

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"Deposit STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)
@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handle M-Pesa B2C payment callback
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"B2C callback received: {callback_data}")

        result = callback_data.get("Result", {})

        if result.get("ResultCode") == 0:
            # Successful B2C payment
            result_parameters = result.get("ResultParameters", {}).get("ResultParameter", [])

            transaction_receipt = None
            transaction_amount = None
            conversation_id = result.get("ConversationID")

            # Extract relevant parameters
            for param in result_parameters:
                if param["Key"] == "TransactionReceipt":
                    transaction_receipt = param["Value"]
                elif param["Key"] == "TransactionAmount":
                    transaction_amount = param["Value"]

            # Get cached B2C payment data if exists
            cached_data = cache.get(f"b2c_{conversation_id}")
            if cached_data:
                # Update payment status or perform business logic here
                # For example, mark disbursement as successful
                logger.info(f"B2C payment successful: Receipt {transaction_receipt}, Amount {transaction_amount}")
                cache.delete(f"b2c_{conversation_id}")
            else:
                logger.info(f"B2C payment successful (no cached data): Receipt {transaction_receipt}, Amount {transaction_amount}")

        else:
            # Failed B2C payment
            logger.error(f"B2C payment failed: {result.get('ResultDesc')}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        logger.error(f"B2C callback error: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})
class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status - FIXED VERSION
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        try:
            payment = Payment.objects.get(id=payment_id)
            
            # Check if user has permission to view this payment
            if request.user.user_type == 'tenant' and payment.tenant != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            return Response({
                "payment_id": payment.id,
                "status": payment.status,
                "amount": float(payment.amount),
                "mpesa_receipt": payment.mpesa_receipt_number if hasattr(payment, 'mpesa_receipt_number') else payment.mpesa_receipt
            })
        except Payment.DoesNotExist:
            return Response({"error": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
# ------------------------------
# DRF CLASS-BASED VIEWS
# ------------------------------

class PaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create rent payments
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            # Landlords can see payments for their properties
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.user)


class PaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()


class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SubscriptionPaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete subscription payment
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)


class RentSummaryView(APIView):
    """
    Get rent summary for landlord
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        # Calculate total collected and outstanding rent
        properties = Property.objects.filter(landlord=user)
        units = Unit.objects.filter(property_obj__in=properties)

        total_collected = Payment.objects.filter(
            unit__in=units,
            status='Success'
        ).aggregate(total=Sum('amount'))['total'] or 0

        total_outstanding = units.aggregate(
            outstanding=Sum('rent_remaining')
        )['outstanding'] or 0

        return Response({
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "properties_count": properties.count(),
            "units_count": units.count()
        })


class UnitTypeListView(generics.ListAPIView):
    """
    List unit types for landlord
    """
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return UnitType.objects.filter(landlord=self.request.user)





class CleanupPendingPaymentsView(APIView):
    """
    Clean up old pending payments - ENHANCED VERSION
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        # Delete pending payments older than 1 hour
        cutoff_time = timezone.now() - timedelta(hours=1)
        
        # Clean up rent payments
        rent_deleted_count = Payment.objects.filter(
            status='Pending',
            created_at__lt=cutoff_time
        ).delete()

        # Clean up subscription payments  
        subscription_deleted_count = SubscriptionPayment.objects.filter(
            status='Pending',
            transaction_date__lt=cutoff_time
        ).delete()

        total_deleted = rent_deleted_count[0] + subscription_deleted_count[0]

        return Response({"message": f"Cleaned up {total_deleted} pending payments"})


# ------------------------------
# CSV EXPORT VIEWS
# ------------------------------

class LandLordCSVView(APIView):
    """
    Export landlord payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, property_id):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        property_obj = get_object_or_404(Property, id=property_id, landlord=user)
        units = Unit.objects.filter(property_obj=property_obj)
        payments = Payment.objects.filter(unit__in=units, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="landlord_payments_{property_obj.name}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Unit Number', 'Tenant', 'Amount', 'Date', 'M-Pesa Receipt'])

        for payment in payments:
            writer.writerow([
                payment.unit.unit_number,
                payment.tenant.full_name if payment.tenant else '',
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or ''
            ])

        return response


class TenantCSVView(APIView):
    """
    Export tenant payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        user = request.user
        unit = get_object_or_404(Unit, id=unit_id)

        if user.user_type == 'tenant' and unit.tenant != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if user.user_type == 'landlord' and unit.property_obj.landlord != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        payments = Payment.objects.filter(unit=unit, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="tenant_payments_unit_{unit.unit_number}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Amount', 'Date', 'M-Pesa Receipt', 'Type'])

        for payment in payments:
            writer.writerow([
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or '',
                payment.payment_type
            ])

        return response


class TestMpesaView(APIView):
    """
    Test endpoint for M-Pesa integration
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({
            "message": "M-Pesa test endpoint",
            "mpesa_env": settings.MPESA_ENV,
            "shortcode": settings.MPESA_SHORTCODE
        })

    def post(self, request):
        # Test token generation
        token = generate_access_token()
        if token:
            return Response({
                "success": True,
                "message": "M-Pesa token generated successfully",
                "token_preview": token[:10] + "..."
            })
        else:
            return Response({
                "success": False,
                "message": "Failed to generate M-Pesa token"
            }, status=400)

# Add this import at the top
from rest_framework.decorators import action
from rest_framework import viewsets
class BulkRentUpdateView(APIView):
    """
    Handle bulk rent updates for units - FIXED VERSION
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            user = request.user
            print(f"🔍 BULK UPDATE - User: {user.email}, Type: {user.user_type}")  # DEBUG
            
            if user.user_type != 'landlord':
                return Response({"error": "Only landlords can update rents"}, status=status.HTTP_403_FORBIDDEN)

            update_type = request.data.get('update_type')  # 'percentage' or 'fixed'
            amount = request.data.get('amount')
            unit_type_filter = request.data.get('unit_type_filter', 'all')
            
            print(f"🔍 BULK UPDATE - Request data: {request.data}")  # DEBUG

            # Validate input
            if not update_type or not amount:
                return Response({"error": "Update type and amount are required"}, status=status.HTTP_400_BAD_REQUEST)

            try:
                amount = float(amount)
                if amount <= 0:
                    return Response({"error": "Amount must be positive"}, status=status.HTTP_400_BAD_REQUEST)
            except (ValueError, TypeError):
                return Response({"error": "Amount must be a valid number"}, status=status.HTTP_400_BAD_REQUEST)

            # Get landlord's units
            landlord_units = Unit.objects.filter(property_obj__landlord=user).select_related('unit_type')
            print(f"🔍 BULK UPDATE - Total landlord units: {landlord_units.count()}")  # DEBUG
            
            # Apply filters - FIXED FILTERING LOGIC
            if unit_type_filter != 'all':
                print(f"🔍 BULK UPDATE - Filtering by unit type: {unit_type_filter}")  # DEBUG
                
                # Check if any units have this unit type name
                units_with_type = landlord_units.filter(unit_type__name=unit_type_filter)
                print(f"🔍 BULK UPDATE - Units with type '{unit_type_filter}': {units_with_type.count()}")  # DEBUG
                
                # Debug: List all available unit types
                available_types = landlord_units.exclude(unit_type__isnull=True).values_list('unit_type__name', flat=True).distinct()
                print(f"🔍 BULK UPDATE - Available unit types: {list(available_types)}")  # DEBUG
                
                landlord_units = units_with_type

            print(f"🔍 BULK UPDATE - Final filtered units: {landlord_units.count()}")  # DEBUG

            # Calculate new rents and prepare updates
            updates = []
            preview_data = []
            
            for unit in landlord_units:
                old_rent = float(unit.rent)
                new_rent = old_rent
                
                if update_type == 'percentage':
                    new_rent = round(old_rent * (1 + amount / 100))
                elif update_type == 'fixed':
                    new_rent = round(old_rent + amount)
                
                # Always include unit in preview, even if rent doesn't change
                preview_data.append({
                    'unit_id': unit.id,
                    'unit_number': unit.unit_number,
                    'unit_type': unit.unit_type.name if unit.unit_type else 'N/A',
                    'old_rent': old_rent,
                    'new_rent': new_rent,
                    'increase': new_rent - old_rent
                })
                
                # Only add to updates if rent actually changes
                if new_rent != old_rent:
                    updates.append({
                        'unit_id': unit.id,
                        'new_rent': new_rent
                    })

            print(f"🔍 BULK UPDATE - Preview data count: {len(preview_data)}")  # DEBUG
            print(f"🔍 BULK UPDATE - Actual updates count: {len(updates)}")  # DEBUG

            # If this is a preview request, return preview data
            if request.data.get('preview_only'):
                total_increase = sum(item['increase'] for item in preview_data)
                total_new_revenue = sum(item['new_rent'] for item in preview_data)
                
                print(f"🔍 BULK UPDATE - Returning preview for {len(preview_data)} units")  # DEBUG
                
                return Response({
                    'preview_data': preview_data,
                    'summary': {
                        'units_affected': len(preview_data),
                        'total_increase': total_increase,
                        'total_new_revenue': total_new_revenue
                    }
                })

            # Apply the actual updates
            updated_count = 0
            for update in updates:
                try:
                    unit = Unit.objects.get(id=update['unit_id'])
                    old_rent = float(unit.rent)
                    unit.rent = update['new_rent']
                    
                    # Recalculate rent remaining based on payments
                    total_paid = Payment.objects.filter(
                        unit=unit, 
                        status='Success',
                        payment_type='rent'
                    ).aggregate(total=Sum('amount'))['total'] or 0
                    
                    unit.rent_paid = total_paid
                    unit.rent_remaining = unit.rent - unit.rent_paid
                    unit.save()
                    updated_count += 1
                    
                    print(f"✅ Updated unit {unit.unit_number}: {old_rent} → {unit.rent}")
                    
                except Unit.DoesNotExist:
                    print(f"❌ Unit not found: {update['unit_id']}")
                    continue
                except Exception as e:
                    logger.error(f"Error updating unit {update['unit_id']}: {str(e)}")
                    continue

            # Log the bulk update
            logger.info(f"Bulk rent update completed by {user.email}. Units updated: {updated_count}")

            return Response({
                'success': True,
                'message': f'Successfully updated rent for {updated_count} units',
                'units_updated': updated_count,
                'details': {
                    'total_units_processed': len(landlord_units),
                    'units_with_rent_changes': len(updates),
                    'units_actually_updated': updated_count
                }
            })

        except Exception as e:
            logger.error(f"Bulk rent update error: {str(e)}", exc_info=True)
            return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class UnitRentUpdateView(APIView):
    """
    Update individual unit rent
    """
    permission_classes = [IsAuthenticated]

    def put(self, request, unit_id):
        try:
            unit = get_object_or_404(Unit, id=unit_id)
            user = request.user

            # Check if user has permission to update this unit
            if user.user_type == 'landlord' and unit.property_obj.landlord != user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            new_rent = request.data.get('rent')
            if not new_rent:
                return Response({"error": "Rent amount is required"}, status=status.HTTP_400_BAD_REQUEST)

            try:
                new_rent = float(new_rent)
                if new_rent <= 0:
                    return Response({"error": "Rent must be positive"}, status=status.HTTP_400_BAD_REQUEST)
            except (ValueError, TypeError):
                return Response({"error": "Rent must be a valid number"}, status=status.HTTP_400_BAD_REQUEST)

            # Update unit rent
            old_rent = float(unit.rent)
            unit.rent = new_rent
            
            # Recalculate rent remaining
            total_paid = Payment.objects.filter(
                unit=unit, 
                status='Success',
                payment_type='rent'
            ).aggregate(total=Sum('amount'))['total'] or 0
            
            unit.rent_paid = total_paid
            unit.rent_remaining = unit.rent - unit.rent_paid
            unit.save()

            logger.info(f"Unit {unit.unit_number} rent updated from {old_rent} to {new_rent} by {user.email}")

            return Response({
                'success': True,
                'message': 'Rent updated successfully',
                'unit': {
                    'id': unit.id,
                    'unit_number': unit.unit_number,
                    'rent': unit.rent,
                    'rent_paid': unit.rent_paid,
                    'rent_remaining': unit.rent_remaining
                }
            })

        except Exception as e:
            logger.error(f"Unit rent update error: {str(e)}")
            return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    BulkRentUpdateView, UnitRentUpdateView,
    InitiateDepositPaymentView,
    InitiateDepositPaymentRegistrationView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    TestMpesaView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path("initiate-deposit-registration/", InitiateDepositPaymentRegistrationView.as_view(), name="initiate-deposit-registration"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    # ------------------------------
    # TEST ENDPOINTS
    # ------------------------------
    path("test-mpesa/", TestMpesaView.as_view(), name="test-mpesa"),
    # Bulk rent update
    path("bulk-rent-update/", BulkRentUpdateView.as_view(), name="bulk-rent-update"),
    path("unit-rent-update/<int:unit_id>/", UnitRentUpdateView.as_view(), name="unit-rent-update"),
]
